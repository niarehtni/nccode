package nc.pubimpl.ta.overtime;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import nc.bs.dao.BaseDAO;
import nc.bs.framework.common.NCLocator;
import nc.impl.ta.overtime.SegdetailMaintainImpl;
import nc.itf.hrwa.IWadaysalaryQueryService;
import nc.itf.ta.IPeriodQueryService;
import nc.pubitf.para.SysInitQuery;
import nc.pubitf.ta.overtime.ISegDetailService;
import nc.vo.bd.shift.ShiftVO;
import nc.vo.hi.psndoc.PsnJobVO;
import nc.vo.hi.psndoc.PsndocVO;
import nc.vo.hrwa.wadaysalary.DaySalaryEnum;
import nc.vo.ml.MultiLangUtil;
import nc.vo.om.hrdept.HRDeptVO;
import nc.vo.om.orginfo.HRHROrgVO;
import nc.vo.pub.BusinessException;
import nc.vo.pub.VOStatus;
import nc.vo.pub.lang.UFBoolean;
import nc.vo.pub.lang.UFDate;
import nc.vo.pub.lang.UFDateTime;
import nc.vo.pub.lang.UFDouble;
import nc.vo.pub.lang.UFLiteralDate;
import nc.vo.ta.leave.LeaveRegVO;
import nc.vo.ta.overtime.AggSegDetailVO;
import nc.vo.ta.overtime.AggSegRuleVO;
import nc.vo.ta.overtime.CalendarDateTypeEnum;
import nc.vo.ta.overtime.MonthStatOTCalcVO;
import nc.vo.ta.overtime.OvertimeLimitScopeEnum;
import nc.vo.ta.overtime.OvertimeRegVO;
import nc.vo.ta.overtime.OvertimeSettleTypeEnum;
import nc.vo.ta.overtime.QueryValueTypeEnum;
import nc.vo.ta.overtime.SegDetailConsumeVO;
import nc.vo.ta.overtime.SegDetailVO;
import nc.vo.ta.overtime.SegRuleTermVO;
import nc.vo.ta.overtime.SegRuleVO;
import nc.vo.ta.overtime.TaxFlagEnum;
import nc.vo.ta.period.PeriodVO;
import nc.vo.ta.psncalendar.PsnCalendarVO;
import nc.vo.ta.timeitem.LeaveTypeCopyVO;
import nc.vo.ta.timeitem.LeaveTypeVO;
import nc.vo.ta.timeitem.OverTimeTypeCopyVO;
import nc.vo.ta.timerule.TimeRuleVO;

import org.apache.commons.lang.StringUtils;

public class SegDetailServiceImpl implements ISegDetailService {
    private Map<String, OTSChainNode> allNode = null;
    private BaseDAO baseDao = null;
    private IPeriodQueryService periodService = null;

    @Override
    public void regOvertimeSegDetail(OvertimeRegVO[] overtimeRegVOs) throws BusinessException {
	if (overtimeRegVOs != null && overtimeRegVOs.length > 0) {
	    this.getAllNode().clear();
	    for (OvertimeRegVO vo : overtimeRegVOs) {
		UFBoolean isEnabled = new UFBoolean(SysInitQuery.getParaString(vo.getPk_org(), "TBMOTSEG"));
		if (isEnabled == null || !isEnabled.booleanValue()) {
		    return;
		}

		String pk_psndoc = vo.getPk_psndoc();

		// 取加班e
		OverTimeTypeCopyVO otType = (OverTimeTypeCopyVO) this.getBaseDao().retrieveByPK(
			OverTimeTypeCopyVO.class, vo.getPk_overtimetypecopy());

		if (otType.getPk_segrule() != null) {
		    // 根加班e取分段依
		    AggSegRuleVO ruleAggVO = getSegRuleAggVO(otType.getPk_segrule());

		    // 取前加班分段明c
		    OTSChainNode curOTSegNode = getOvertimeSegChainNodeByOTReg(vo, ruleAggVO);

		    // 取前人T全c（物理表）
		    if (!this.getAllNode().containsKey(pk_psndoc)) {
			OTSChainNode psnNode = OTSChainUtils.buildChainNodes(pk_psndoc, null, null, false, false,
				false, false, false);
			this.getAllNode().put(pk_psndoc, psnNode);
		    }

		    // 校加班日是否已存在不同的加班分段依
		    OTSChainNode checkNode = this.getAllNode().get(pk_psndoc);
		    while (checkNode != null) {
			if (checkNode.getNodeData().getRegdate().isSameDate(curOTSegNode.getNodeData().getRegdate())) {
			    // 已存在cc前加班日橥一天
			    if (!otType.getPk_segrule().equals(checkNode.getNodeData().getPk_segrule())) {
				throw new BusinessException("系y中已存在使用不同型的加班分段t的加班登巍 ");
			    }
			}
			checkNode = checkNode.getNextNode();
		    }

		    OTSChainNode combinedNodes = OTSChainUtils.combineNodes(this.getAllNode().get(pk_psndoc),
			    curOTSegNode);
		    this.getAllNode().put(pk_psndoc, combinedNodes);
		    OTSChainUtils.saveAll(this.getAllNode().get(pk_psndoc));
		}
	    }
	}
    }

    @Override
    public void updateOvertimeSegDetail(OvertimeRegVO[] overtimeRegVOs) throws BusinessException {
	if (overtimeRegVOs != null && overtimeRegVOs.length > 0) {
	    deleteOvertimeSegDetail(overtimeRegVOs);
	    regOvertimeSegDetail(overtimeRegVOs);
	}

    }

    @Override
    public void deleteOvertimeSegDetail(OvertimeRegVO[] overtimeRegVOs) throws BusinessException {
	if (overtimeRegVOs != null && overtimeRegVOs.length > 0) {
	    List<AggSegDetailVO> aggvos = new ArrayList<AggSegDetailVO>();

	    for (OvertimeRegVO vo : overtimeRegVOs) {
		OTSChainNode curNode = OTSChainUtils.buildChainNodes(vo.getPk_psndoc(), null, vo.getPk_overtimereg(),
			false, false, false, false, false);
		boolean canDel = true;
		while (curNode != null) {
		    if (curNode.getNodeData().getConsumedhours().doubleValue() > 0
			    || containsChild(curNode.getNodeData().getPk_segdetail())) {
			canDel = false;
			break;
		    }

		    AggSegDetailVO aggvo = new AggSegDetailVO();
		    aggvo.setParent(curNode.getNodeData());
		    aggvos.add(aggvo);

		    curNode = curNode.getNextNode();
		}

		if (!canDel) {
		    throw new BusinessException("加班登的分段明已被消耗");
		}

	    }

	    if (aggvos.size() > 0) {
		new SegdetailMaintainImpl().delete(aggvos.toArray(new AggSegDetailVO[0]));
	    }
	}
    }

    private boolean containsChild(String pk_segdetail) throws BusinessException {
	Collection children = this.getBaseDao().retrieveByClause(SegDetailConsumeVO.class,
		"pk_segdetail='" + pk_segdetail + "'");
	return (children != null && children.size() > 0);
    }

    private OTSChainNode getOvertimeSegChainNodeByOTReg(OvertimeRegVO vo, AggSegRuleVO ruleAggVO)
	    throws BusinessException {
	SegRuleVO rule = ruleAggVO.getParentVO();
	SegRuleTermVO[] terms = (SegRuleTermVO[]) ruleAggVO.getChildrenVO();

	UFDouble othours = vo.getOvertimehour();
	UFDouble totalSegHours = UFDouble.ZERO_DBL; // n生成分段rL
	OTSChainNode parentNode = null;
	UFLiteralDate realDate = getShiftRegDate(vo);

	for (SegRuleTermVO term : terms) {
	    if (othours.equals(UFDouble.ZERO_DBL)) {
		break;
	    }
	    UFDouble start = term.getStartpoint();
	    UFDouble end = term.getEndpoint() == null ? new UFDouble(24) : term.getEndpoint();
	    UFDouble taxfreerate = term.getTaxfreeotrate();
	    UFDouble taxablerate = term.getTaxableotrate();
	    UFDouble seghours = end.sub(start); // 分段rL
	    UFDouble curSegTotalHours = UFDouble.ZERO_DBL; // 前分段rL
	    UFDouble curSegTaxfreeHours = UFDouble.ZERO_DBL; // 前分段免rL
	    UFDouble curSegTaxableHours = UFDouble.ZERO_DBL; // 前分段rL
	    if (othours.doubleValue() >= seghours.doubleValue()) {
		// 加班rL大於分段L度，本次]rL取分段rL
		curSegTotalHours = seghours;
	    } else {
		// 加班rL小於分段L度，本次]rL取加班rL
		curSegTotalHours = othours;
	    }

	    othours = othours.sub(curSegTotalHours);

	    if (term.getIslimitscope() == null || !term.getIslimitscope().booleanValue()) {
		// 不入加班上限y，直接槊舛r
		curSegTaxfreeHours = curSegTotalHours;
		curSegTaxableHours = UFDouble.ZERO_DBL;
	    } else {
		// 先z查分段依上，分段的免O置
		if (term.getTaxflag().equals(TaxFlagEnum.TAXABLE.toIntValue())) {
		    curSegTaxfreeHours = UFDouble.ZERO_DBL;
		    curSegTaxableHours = curSegTotalHours;
		} else {
		    // 入加班上限y，z查日截止日前一日的加班r
		    Map<String, UFDouble[]> psnSeghours = this.calculateTaxableByDate(vo.getPk_org(),
			    new String[] { vo.getPk_psndoc() }, realDate, realDate, curSegTotalHours);
		    curSegTaxfreeHours = psnSeghours.get(vo.getPk_psndoc())[0];
		    curSegTaxableHours = psnSeghours.get(vo.getPk_psndoc())[1];
		}
	    }

	    OTSChainNode curNode = new OTSChainNode();
	    SegDetailVO segvo = createNewSegDetail(vo, realDate, rule, term, seghours, taxfreerate, taxablerate,
		    curSegTaxfreeHours, curSegTaxableHours);

	    curNode.setNodeData(segvo);

	    if (parentNode == null) {
		curNode.setNextNode(null);
		curNode.setPriorNode(null);
		parentNode = curNode;
	    } else {
		OTSChainUtils.appendNode(parentNode, curNode);
		parentNode = curNode;
	    }

	    totalSegHours = totalSegHours.add(curSegTotalHours);// 生成分段rLn加
	}
	return OTSChainUtils.getFirstNode(parentNode);
    }

    private SegDetailVO createNewSegDetail(OvertimeRegVO vo, UFLiteralDate realRegDate, SegRuleVO rule,
	    SegRuleTermVO term, UFDouble seghours, UFDouble taxfreerate, UFDouble taxablerate, UFDouble hourstaxfree,
	    UFDouble hourstaxable) throws BusinessException {
	SegDetailVO segvo = new SegDetailVO();
	segvo.setPk_group(vo.getPk_group());
	segvo.setPk_org(vo.getPk_org());
	segvo.setPk_org_v(vo.getPk_org_v());
	segvo.setPk_overtimereg(vo.getPk_overtimereg());
	segvo.setPk_psndoc(vo.getPk_psndoc());
	segvo.setPk_segrule(rule.getPk_segrule());
	segvo.setPk_segruleterm(term.getPk_segruleterm());
	segvo.setConsumedhours(UFDouble.ZERO_DBL);
	UFDouble hourpay = getPsnHourPay(vo.getPk_psndoc(), vo.getOvertimebegindate(), DaySalaryEnum.TBMHOURSALARY);
	segvo.setHourlypay(hourpay == null ? UFDouble.ZERO_DBL : hourpay);
	segvo.setHourstaxfree(hourstaxfree);
	segvo.setHourstaxable(hourstaxable);
	segvo.setHours(segvo.getHourstaxfree().add(segvo.getHourstaxable()));
	segvo.setIscanceled(UFBoolean.FALSE);
	segvo.setIscompensation(vo.getIstorest());
	segvo.setHourstorest(vo.getToresthour());
	segvo.setIsconsumed(UFBoolean.FALSE);
	segvo.setIssettled(UFBoolean.FALSE);
	segvo.setMaketime(new UFDate());
	PsndocVO psnVo = (PsndocVO) this.getBaseDao().retrieveByPK(PsndocVO.class, vo.getPk_psndoc());
	segvo.setNodecode(psnVo.getCode() + OTSChainUtils.SPLT + realRegDate.toString() + OTSChainUtils.SPLT
		+ rule.getCode() + OTSChainUtils.SPLT + String.valueOf(String.format("%02d", term.getSegno())));
	segvo.setNodename(MultiLangUtil.getSuperVONameOfCurrentLang(psnVo, PsndocVO.NAME, psnVo.getName())
		+ OTSChainUtils.SPLT + realRegDate.toString().replace("-", "") + OTSChainUtils.SPLT
		+ MultiLangUtil.getSuperVONameOfCurrentLang(rule, SegRuleVO.NAME, rule.getName()) + OTSChainUtils.SPLT
		+ String.valueOf(term.getSegno()));
	segvo.setTaxfreerate(taxfreerate);
	segvo.setTaxablerate(taxablerate);
	segvo.setRegdate(realRegDate);
	segvo.setRemainhours(segvo.getHours());
	segvo.setRemainamounttaxfree(getOTAmount(segvo.getTaxfreerate(), segvo.getHourlypay(), segvo.getTaxfreerate(),
		null, -1));
	segvo.setRemainamounttaxable(getOTAmount(segvo.getTaxablerate(), segvo.getHourlypay(), segvo.getTaxablerate(),
		null, -1));
	segvo.setRemainamount(segvo.getRemainamounttaxfree().add(segvo.getRemainamounttaxable())); // 剩N金~=剩N金~（免）+剩N金~（）
	segvo.setRulehours(seghours);
	return segvo;
    }

    /**
     * 根加班核定_始日期查加班Hw侔啻蔚乃偃掌
     * 
     * @param vo
     *            加班登
     * @return
     * @throws BusinessException
     */
    @SuppressWarnings("unchecked")
    private UFLiteralDate getShiftRegDate(OvertimeRegVO vo) throws BusinessException {
	UFLiteralDate rtnDate = vo.getBegindate();
	Collection<PsnCalendarVO> psncals = this.getBaseDao().retrieveByClause(
		PsnCalendarVO.class,
		"pk_psndoc='" + vo.getPk_psndoc() + "' and calendar between '"
			+ vo.getOvertimebegindate().getDateBefore(3) + "' and '"
			+ vo.getOvertimebegindate().getDateAfter(3) + "'");
	if (psncals != null && psncals.size() > 0) {
	    for (PsnCalendarVO psncal : psncals) {
		if (psncal.getPk_shift() != null) {
		    ShiftVO shiftvo = (ShiftVO) this.getBaseDao().retrieveByPK(ShiftVO.class, psncal.getPk_shift());
		    if (shiftvo != null) {
			UFDateTime startDT = null;
			if (shiftvo.getTimebeginday() == 0) {
			    startDT = new UFDateTime(psncal.getCalendar().toString() + " " + shiftvo.getBegintime());
			} else {
			    startDT = new UFDateTime(psncal.getCalendar().getDateAfter(1).toString() + " "
				    + shiftvo.getBegintime());
			}

			UFDateTime endDT = null;
			if (shiftvo.getTimeendday() == 0) {
			    endDT = new UFDateTime(psncal.getCalendar().toString() + " " + shiftvo.getEndtime());
			} else {
			    endDT = new UFDateTime(psncal.getCalendar().getDateAfter(1).toString() + " "
				    + shiftvo.getEndtime());
			}

			if (vo.getOvertimebegintime().before(endDT) && vo.getOvertimebegintime().after(startDT)) {
			    rtnDate = psncal.getCalendar();
			}
		    }
		}
	    }
	}
	return rtnDate;
    }

    private UFDouble getOTAmount(UFDouble otRate, UFDouble hourlypay, UFDouble hours, SegDetailVO detailVO,
	    int daySalType) throws BusinessException {
	otRate = otRate == null ? UFDouble.ZERO_DBL : otRate;
	hourlypay = hourlypay == null ? UFDouble.ZERO_DBL : hourlypay;
	hours = hours == null ? UFDouble.ZERO_DBL : hours;
	if (detailVO != null) {
	    hourlypay = getPsnHourPay(detailVO.getPk_psndoc(), detailVO.getRegdate(), daySalType);
	    detailVO.setHourlypay(hourlypay);
	}
	UFDouble amount = hourlypay.multiply(otRate).multiply(hours);
	return amount;
    }

    private UFDouble getPsnHourPay(String pk_psndoc, UFLiteralDate overtimebegindate, int daySalType)
	    throws BusinessException {
	IWadaysalaryQueryService dayPaySvc = NCLocator.getInstance().lookup(IWadaysalaryQueryService.class);

	Map<String, HashMap<UFLiteralDate, UFDouble>> dayPayMap = dayPaySvc.getTotalTbmDaySalaryMap(
		new String[] { pk_psndoc }, overtimebegindate, overtimebegindate, daySalType);
	if (dayPayMap == null || dayPayMap.size() == 0 || dayPayMap.get(pk_psndoc) == null
		|| dayPayMap.get(pk_psndoc).get(overtimebegindate) == null) {
	    // throw new BusinessException("人Tr薪取值e`：人Tr薪榭");
	    return UFDouble.ZERO_DBL; // 未取到日薪的，r返回0
	}
	return dayPayMap.get(pk_psndoc).get(overtimebegindate);
    }

    @SuppressWarnings("unchecked")
    private AggSegRuleVO getSegRuleAggVO(String pk_segrule) throws BusinessException {
	SegRuleVO ruleVO = (SegRuleVO) this.getBaseDao().retrieveByPK(SegRuleVO.class, pk_segrule);

	if (ruleVO == null) {
	    throw new BusinessException("e`：加班分段t已被h除");
	}

	Collection<SegRuleTermVO> segTerms = this.getBaseDao().retrieveByClause(SegRuleTermVO.class,
		"pk_segrule='" + pk_segrule + "' and dr=0", "segno");
	if (segTerms == null || segTerms.size() == 0) {
	    throw new BusinessException("e`：加班分段t明已被h除");
	}

	AggSegRuleVO aggVo = new AggSegRuleVO();
	aggVo.setParent(ruleVO);
	aggVo.setChildrenVO(segTerms.toArray(new SegRuleTermVO[0]));

	return aggVo;
    }

    @Override
    public void regOvertimeSegDetailConsume(LeaveRegVO[] leaveRegVOs) throws BusinessException {
	if (leaveRegVOs != null && leaveRegVOs.length > 0) {
	    for (LeaveRegVO vo : leaveRegVOs) {
		UFBoolean isEnabled = SysInitQuery.getParaBoolean(vo.getPk_org(), "TBMOTSEG");
		if (isEnabled == null || !isEnabled.booleanValue()) {
		    return;
		}

		// 取I刀x的加班分段休假e（加班Da休）
		LeaveTypeCopyVO[] lvTypeVOs = getLeaveTypeVOs(vo.getPk_org());

		boolean typeContains = false;
		for (LeaveTypeCopyVO lvTypeVO : lvTypeVOs) {
		    if (lvTypeVO.getPk_timeitemcopy().equals(vo.getPk_leavetypecopy())) {
			typeContains = true;
			break;
		    }
		}

		if (typeContains) {
		    // 取已]晕聪耗的加班分段明
		    // 取前人T^Vc（表：Da休，未作U，未核消完，未Y算）
		    OTSChainNode psnNode = OTSChainUtils.buildChainNodes(vo.getPk_psndoc(), null, null, true, false,
			    true, true, true);
		    SegDetailVO[] segDetailBeConsumed = OTSChainUtils.getAllNodeData(psnNode);

		    if (segDetailBeConsumed == null || segDetailBeConsumed.length == 0) {
			throw new BusinessException("消耗加班分段明失。何凑业娇捎玫募影喾侄蚊骷。");
		    }

		    consumeSegDetailHours(segDetailBeConsumed, vo);
		}
	    }
	}
    }

    @Override
    public void updateOvertimeSegDetailConsume(LeaveRegVO[] leaveRegVOs) throws BusinessException {
	if (leaveRegVOs != null && leaveRegVOs.length > 0) {
	    deleteOvertimeSegDetailConsume(leaveRegVOs);
	    regOvertimeSegDetailConsume(leaveRegVOs);
	}
    }

    @SuppressWarnings("unchecked")
    @Override
    public void deleteOvertimeSegDetailConsume(LeaveRegVO[] leaveRegVOs) throws BusinessException {
	if (leaveRegVOs != null && leaveRegVOs.length > 0) {
	    for (LeaveRegVO vo : leaveRegVOs) {
		Collection<SegDetailConsumeVO> consumeVOs = this.getBaseDao().retrieveByClause(
			SegDetailConsumeVO.class, "pk_leavereg='" + vo.getPk_leavereg() + "'");
		for (SegDetailConsumeVO consumeVO : consumeVOs) {
		    SegDetailVO detailVO = (SegDetailVO) this.getBaseDao().retrieveByPK(SegDetailVO.class,
			    consumeVO.getPk_segdetail());
		    Map<String, UFDouble[]> taxhourssplit = calculateTaxableByDate(vo.getPk_org(),
			    new String[] { vo.getPk_psndoc() }, detailVO.getRegdate(), detailVO.getRegdate()
				    .getDateBefore(1), vo.getLeavehour());
		    UFDouble[] values = taxhourssplit.get(vo.getPk_psndoc());
		    detailVO.setRemainhourstaxfree(detailVO.getRemainhourstaxfree().add(values[0]));
		    detailVO.setRemainhourstaxable(detailVO.getRemainhourstaxable().add(values[1]));
		    detailVO.setRemainhours(detailVO.getRemainhourstaxfree().add(detailVO.getRemainhourstaxable()));

		    detailVO.setRemainamounttaxfree(getOTAmount(detailVO.getTaxfreerate(), detailVO.getHourlypay(),
			    detailVO.getRemainhourstaxfree(), detailVO, DaySalaryEnum.TAXFREEHOURSALARY));
		    detailVO.setRemainamounttaxable(getOTAmount(detailVO.getTaxablerate(), detailVO.getHourlypay(),
			    detailVO.getRemainhourstaxable(), detailVO, DaySalaryEnum.TAXABLEHOURSALARY));
		    detailVO.setRemainamount(detailVO.getRemainamounttaxfree().add(detailVO.getRemainamounttaxable()));

		    detailVO.setConsumedhourstaxfree(detailVO.getConsumedhourstaxfree().sub(values[0]));
		    detailVO.setConsumedhourstaxable(detailVO.getConsumedhourstaxable().sub(values[1]));
		    detailVO.setConsumedhours(detailVO.getConsumedhourstaxfree()
			    .add(detailVO.getConsumedhourstaxable()));

		    this.getBaseDao().updateVO(detailVO);
		    this.getBaseDao().deleteVO(consumeVO);
		}
	    }
	}
    }

    private void consumeSegDetailHours(SegDetailVO[] segDetailVOs, LeaveRegVO vo) throws BusinessException {
	List<AggSegDetailVO> aggvos = new ArrayList<AggSegDetailVO>();
	UFDouble unConsumedLeaveHours = vo.getLeavehour();
	for (SegDetailVO segDetail : segDetailVOs) {
	    // 先M先出匹配
	    if (!unConsumedLeaveHours.equals(UFDouble.ZERO_DBL)) {
		// 本P核Nr
		UFDouble curConsumedHours = UFDouble.ZERO_DBL;
		if (segDetail.getRemainhours().doubleValue() >= vo.getLeavehour().doubleValue()) {
		    // 剩N小r荡箪兜褥侗敬魏虽Nr=本次核N全部在本l明完成
		    curConsumedHours = unConsumedLeaveHours;
		} else {
		    // 剩N小r敌§侗敬魏虽Nr=本次核N在本l明完成部分
		    curConsumedHours = segDetail.getRemainhours();
		    // N下部分^m向後核N
		    unConsumedLeaveHours = vo.getLeavehour().sub(segDetail.getRemainhours());
		}

		consumeSegDetailHours(curConsumedHours, segDetail); // 理本P核N
		SegDetailConsumeVO consumeVO = getNewConsumeVO(vo, segDetail); // 生成核N明
		AggSegDetailVO aggvo = new AggSegDetailVO();
		segDetail.setStatus(VOStatus.UPDATED);
		aggvo.setParent(segDetail);
		consumeVO.setStatus(VOStatus.NEW);
		aggvo.setChildren(SegDetailConsumeVO.class, new SegDetailConsumeVO[] { consumeVO });
		aggvos.add(aggvo);
		unConsumedLeaveHours = unConsumedLeaveHours.sub(curConsumedHours);
	    }
	}

	if (aggvos.size() > 0) {
	    new SegdetailMaintainImpl().update(aggvos.toArray(new AggSegDetailVO[0]));
	}
    }

    private SegDetailConsumeVO getNewConsumeVO(LeaveRegVO vo, SegDetailVO segDetail) {
	SegDetailConsumeVO consumeVO = new SegDetailConsumeVO();
	consumeVO.setPk_group(segDetail.getPk_group());
	consumeVO.setPk_org(segDetail.getPk_org());
	consumeVO.setPk_org_v(segDetail.getPk_org_v());
	consumeVO.setPk_segdetail(segDetail.getPk_segdetail());
	consumeVO.setPk_leavereg(vo.getPk_leavereg());
	consumeVO.setBizdate(vo.getLeavebegindate());
	consumeVO.setBiztype(vo.getBillType());
	return consumeVO;
    }

    // 先消耗免部分，再消耗部分
    private void consumeSegDetailHours(UFDouble unConsumedHours, SegDetailVO segDetail) throws BusinessException {
	SegRuleTermVO term = (SegRuleTermVO) this.getBaseDao().retrieveByPK(SegRuleTermVO.class,
		segDetail.getPk_segruleterm());

	// 免部分
	if (segDetail.getRemainamounttaxfree().doubleValue() > 0) {
	    if (unConsumedHours.doubleValue() <= segDetail.getRemainamounttaxfree().doubleValue()) {
		// 只消耗免部分
		segDetail.setRemainhourstaxfree(segDetail.getRemainhourstaxfree().sub(unConsumedHours));
		segDetail.setConsumedhourstaxfree(segDetail.getConsumedhourstaxfree().add(unConsumedHours));
		segDetail.setRemainhours(segDetail.getRemainhours().sub(unConsumedHours));
		segDetail.setConsumedhours(segDetail.getConsumedhours().add(unConsumedHours));
	    } else {
		// 消耗免全部後，剩N消耗部分
		UFDouble tmpHours = unConsumedHours.sub(segDetail.getRemainamounttaxfree());
		segDetail.setRemainhourstaxfree(segDetail.getRemainhourstaxfree().sub(tmpHours));
		segDetail.setConsumedhourstaxfree(segDetail.getConsumedhourstaxfree().add(tmpHours));
		segDetail.setRemainhours(segDetail.getRemainhours().sub(tmpHours));
		segDetail.setConsumedhours(segDetail.getConsumedhours().add(tmpHours));

		tmpHours = unConsumedHours.sub(tmpHours);
		segDetail.setRemainhourstaxable(segDetail.getRemainhourstaxable().sub(tmpHours));
		segDetail.setConsumedhourstaxable(segDetail.getConsumedhourstaxable().add(tmpHours));
		segDetail.setRemainhours(segDetail.getRemainhours().sub(tmpHours));
		segDetail.setConsumedhours(segDetail.getConsumedhours().add(tmpHours));
	    }
	} else {
	    // 只消耗部分
	    segDetail.setRemainhourstaxable(segDetail.getRemainhourstaxable().sub(unConsumedHours));
	    segDetail.setConsumedhourstaxable(segDetail.getConsumedhourstaxable().add(unConsumedHours));
	    segDetail.setRemainhours(segDetail.getRemainhours().sub(unConsumedHours));
	    segDetail.setConsumedhours(segDetail.getConsumedhours().add(unConsumedHours));
	}

	// 算加班M
	segDetail.setRemainamounttaxfree(getOTAmount(term.getTaxfreeotrate(), segDetail.getHourlypay(),
		segDetail.getRemainhourstaxfree(), segDetail, DaySalaryEnum.TAXFREEHOURSALARY));
	segDetail.setRemainamounttaxable(getOTAmount(term.getTaxableotrate(), segDetail.getHourlypay(),
		segDetail.getRemainhourstaxable(), segDetail, DaySalaryEnum.TAXABLEHOURSALARY));
	segDetail.setRemainamount(segDetail.getRemainamounttaxfree().add(segDetail.getRemainamounttaxable()));

	unConsumedHours = UFDouble.ZERO_DBL;
	if (segDetail.getRemainhours().doubleValue() == 0) {
	    // O置已消耗完
	    segDetail.setIsconsumed(UFBoolean.TRUE);
	}
    }

    Map<String, LeaveTypeCopyVO[]> leaveTypeVOMap = null;

    @SuppressWarnings("unchecked")
    private LeaveTypeCopyVO[] getLeaveTypeVOs(String pk_org) throws BusinessException {
	if (leaveTypeVOMap == null) {
	    leaveTypeVOMap = new HashMap<String, LeaveTypeCopyVO[]>();
	}

	if (!leaveTypeVOMap.containsKey(pk_org)) {
	    String leaveTypeRefCode = SysInitQuery.getParaString(pk_org, "TBMOTTYPE");

	    if (StringUtils.isEmpty(leaveTypeRefCode)) {
		throw new BusinessException("等≈凳。赫在I翟O置-M中O定本M [加班分段休假e编码] 怠");
	    }

	    String[] leaveTypeCodes = leaveTypeRefCode.split(",");
	    String typeCond = "";
	    for (String code : leaveTypeCodes) {
		if (StringUtils.isEmpty(typeCond.trim())) {
		    typeCond = "'" + code + "'";
		} else {
		    typeCond += " , '" + code + "'";
		}
	    }
	    Collection<LeaveTypeVO> leaveTypeVOs = this.getBaseDao().retrieveByClause(LeaveTypeVO.class,
		    "timeitemcode in (" + typeCond + ")");

	    if (leaveTypeVOs == null || leaveTypeVOs.size() == 0) {
		throw new BusinessException("未定xM抵兄付ǖ木a [" + typeCond.replace("'", "") + "] 休假e。");
	    } else {
		String inPks = "";
		for (LeaveTypeVO vo : leaveTypeVOs) {
		    if (StringUtils.isEmpty(inPks)) {
			inPks = "'" + vo.getPk_timeitem() + "'";
		    } else {
			inPks += ", '" + vo.getPk_timeitem() + "'";
		    }
		}
		Collection<LeaveTypeCopyVO> leaveTypeVos = this.getBaseDao().retrieveByClause(LeaveTypeCopyVO.class,
			"pk_org='" + pk_org + "' and pk_timeitem in (" + inPks + ")");

		leaveTypeVOMap.put(pk_org, leaveTypeVos.toArray(new LeaveTypeCopyVO[0]));
	    }
	}

	return leaveTypeVOMap.get(pk_org);
    }

    @SuppressWarnings("unchecked")
    private TimeRuleVO getTimeRule(String pk_org) throws BusinessException {
	// 取T工考勤t
	Collection<TimeRuleVO> timerule = this.getBaseDao().retrieveByClause(TimeRuleVO.class,
		"pk_org='" + pk_org + "' and dr=0");
	if (timerule == null) {
	    throw new BusinessException("取考勤te`：指定M下未定x考勤t");
	}

	return timerule.toArray(new TimeRuleVO[0])[0];
    }

    Map<String, Integer> sysManageScope = new HashMap<String, Integer>();
    Map<String, PsndocVO> psndocMap = new HashMap<String, PsndocVO>();

    @Override
    public Map<String, UFDouble[]> calculateTaxableByDate(String pk_org, String[] pk_psndocs, UFLiteralDate startDate,
	    UFLiteralDate endDate, UFDouble curNodeHours) throws BusinessException {
	Map<String, UFDouble[]> ret = new HashMap<String, UFDouble[]>();
	if (pk_psndocs != null && pk_psndocs.length > 0) {
	    for (String pk_psndoc : pk_psndocs) {
		UFDouble[] retValues = new UFDouble[2];
		retValues[0] = UFDouble.ZERO_DBL;
		retValues[1] = UFDouble.ZERO_DBL;
		UFDouble totalTaxFreeAmount = UFDouble.ZERO_DBL;
		UFDouble totalTaxableAmount = UFDouble.ZERO_DBL;
		UFDouble totalHours = UFDouble.ZERO_DBL;

		OTSChainNode curNode = OTSChainUtils.buildChainNodes(pk_psndoc, null, null, true, true, true, true,
			true);
		// 考勤t
		TimeRuleVO timerule = getTimeRule(pk_org);

		// 取T工Y算L期
		OvertimeLimitScopeEnum curStatScope = getPsnStatScope(pk_org, pk_psndoc);

		// 一L期燃影嗖荒艹^的r
		UFDouble taxFreeLimitHours = timerule.getCtrlothours();
		// 一或三L期燃影嗖荒艹^的r
		UFDouble totalTaxFreeLimitHours = taxFreeLimitHours;

		PeriodVO[] threePeriods = null;
		PeriodVO periodCurrent = getPeriodService().queryByDate(pk_org, startDate);
		if (periodCurrent == null) {
		    throw new BusinessException("取前期ge`");
		}

		if (curStatScope.equals(OvertimeLimitScopeEnum.THREEMONTH)) {
		    taxFreeLimitHours = timerule.getCtrlothours3();
		    totalTaxFreeLimitHours = timerule.getCtrlothours3();
		    threePeriods = getThreePeriodVOs(pk_org, startDate, pk_psndoc, periodCurrent);
		} else {
		    threePeriods = new PeriodVO[1];
		    threePeriods[0] = periodCurrent;
		}

		UFLiteralDate sumStartDate = threePeriods[0].getBegindate();
		UFLiteralDate sumEndDate = threePeriods.length == 3 ? threePeriods[2].getEnddate() : threePeriods[0]
			.getEnddate();

		if (endDate != null) {
		    sumEndDate = sumEndDate.after(endDate) ? endDate : sumEndDate;
		}

		// 是否免
		boolean isTaxFree = true;
		if (curNode != null) {
		    while (curNode != null) {
			// 前cr挡榭眨前c明榭盏模即樽钺嵋淮芜M入
			if (curNode.getNodeData() == null && curNodeHours != null) {
			    if (!isTaxFree) {
				// 已M入
				totalTaxFreeAmount = UFDouble.ZERO_DBL;
				totalTaxableAmount = curNodeHours;
			    } else {
				if (totalHours.add(curNodeHours).doubleValue() <= totalTaxFreeLimitHours.doubleValue()) {
				    // 加後仍在免r倒
				    totalTaxFreeAmount = curNodeHours;
				    totalTaxableAmount = UFDouble.ZERO_DBL;
				} else {
				    // 正好超^免r
				    totalTaxableAmount = totalHours.add(curNodeHours).sub(totalTaxFreeLimitHours);
				    totalTaxFreeAmount = curNodeHours.sub(totalTaxableAmount);
				}
			    }
			    break;
			}

			if (curNode.getNodeData().getPk_org().equals(pk_org)) {
			    // 在日期
			    if (curNode.getNodeData().getRegdate().isSameDate(sumStartDate)
				    || curNode.getNodeData().getRegdate().after(sumStartDate)
				    && (curNode.getNodeData().getRegdate().isSameDate(sumEndDate) || curNode
					    .getNodeData().getRegdate().before(sumEndDate))) {
				UFDouble curHours = getHoursInScope(curNode.getNodeData());

				// n加加班r
				totalHours = totalHours.add(curHours);
				if (isTaxFree) {
				    if (totalHours.doubleValue() <= totalTaxFreeLimitHours.doubleValue()) {
					// 在免r倒鹊模n到免加班M
					totalTaxFreeAmount = totalTaxFreeAmount.add(getOTAmount(curNode.getNodeData()
						.getTaxfreerate(), curNode.getNodeData().getHourlypay(), curNode
						.getNodeData().getHourstaxfree(), curNode.getNodeData(),
						DaySalaryEnum.TAXFREEHOURSALARY));
				    } else {
					// 正好超^免r
					// 超^r挡 * r薪 * 加班M率 = 第一P加班M
					totalTaxableAmount = getOTAmount(curNode.getNodeData().getTaxablerate(),
						curNode.getNodeData().getHourlypay(),
						totalHours.sub(totalTaxFreeLimitHours), curNode.getNodeData(),
						DaySalaryEnum.TAXABLEHOURSALARY);
					// 本P未消耗加班M - 第一P加班M = 最後一P免加班M
					totalTaxFreeAmount = totalTaxFreeAmount.add(getOTAmount(curNode.getNodeData()
						.getTaxfreerate(), curNode.getNodeData().getHourlypay(), curHours
						.sub(totalHours.sub(totalTaxFreeLimitHours)), curNode.getNodeData(),
						DaySalaryEnum.TAXFREEHOURSALARY));
					isTaxFree = false;
				    }
				} else {
				    // 超^免r倒的，n到加班M
				    totalTaxableAmount = totalTaxableAmount.add(getOTAmount(curNode.getNodeData()
					    .getTaxablerate(), curNode.getNodeData().getHourlypay(), curNode
					    .getNodeData().getHourlypay(), curNode.getNodeData(),
					    DaySalaryEnum.TAXABLEHOURSALARY));
				}
			    }
			    curNode = curNode.getNextNode();

			    if (curNodeHours != null && curNode == null) {
				curNode = new OTSChainNode();
			    }
			}
		    }
		    retValues[0] = totalTaxFreeAmount;
		    retValues[1] = totalTaxableAmount;
		}
		ret.put(pk_psndoc, retValues);
	    }
	}
	return ret;
    }

    private PeriodVO[] getThreePeriodVOs(String pk_org, UFLiteralDate startDate, String pk_psndoc,
	    PeriodVO periodCurrent) throws BusinessException {
	PeriodVO[] threePeriods;
	PsndocVO psndoc = psndocMap.get(pk_psndoc);
	// 起算期g
	PeriodVO periodStart = (PeriodVO) this.getBaseDao().retrieveByPK(PeriodVO.class,
		(String) psndoc.getAttributeValue("otchkstartperiod"));

	int startMonth = Integer.valueOf(periodStart.getTimemonth());
	int currentMonth = startDate.getMonth();

	threePeriods = new PeriodVO[3];
	if (startMonth % 3 == currentMonth % 3) {
	    // 0:0 1:1 2:2 後a2
	    // 前期g槠鹗计陂g，後a期g
	    threePeriods[0] = periodCurrent;
	    threePeriods[1] = this.getPeriodService().queryNextPeriod(pk_org, threePeriods[0].getBegindate());
	    threePeriods[2] = this.getPeriodService().queryNextPeriod(pk_org, threePeriods[1].getBegindate());
	} else if (((currentMonth % 3) - (startMonth % 3) == 1) || (currentMonth % 3 + 3) - (startMonth % 3) == 1) {
	    // 0:1 1:2 2:0 前後各1
	    // 前期g橹虚g期g，前後各a一期g
	    threePeriods[1] = periodCurrent;
	    threePeriods[0] = this.getPeriodService().queryPreviousPeriod(pk_org, threePeriods[1].getBegindate());
	    threePeriods[2] = this.getPeriodService().queryNextPeriod(pk_org, threePeriods[1].getBegindate());
	} else {
	    // 0:2 1:0 2:1 前a2
	    // 前期g樽钺嵋期g，前a期g
	    threePeriods[2] = periodCurrent;
	    threePeriods[1] = this.getPeriodService().queryPreviousPeriod(pk_org, threePeriods[2].getBegindate());
	    threePeriods[0] = this.getPeriodService().queryPreviousPeriod(pk_org, threePeriods[1].getBegindate());
	}
	return threePeriods;
    }

    Map<String, SegRuleTermVO> mapSegTerm = new HashMap<String, SegRuleTermVO>();

    private UFDouble getHoursInScope(SegDetailVO segdetail) throws BusinessException {
	SegRuleTermVO term = null;
	if (!mapSegTerm.containsKey(segdetail.getPk_segruleterm())) {
	    term = (SegRuleTermVO) this.getBaseDao().retrieveByPK(SegRuleTermVO.class, segdetail.getPk_segruleterm());
	} else {
	    term = mapSegTerm.get(segdetail.getPk_segruleterm());
	}

	UFDouble rtn = UFDouble.ZERO_DBL;
	if (term.getIslimitscope() != null && term.getIslimitscope().booleanValue()) {
	    // 入加班上限y
	    rtn = segdetail.getHours();
	}
	return rtn;
    }

    @SuppressWarnings("unchecked")
    private OvertimeLimitScopeEnum getPsnStatScope(String pk_org, String pk_psndoc) throws BusinessException {
	int manageScope = -1;
	// 系y担杭影嗌舷捱L期管理e（公司，部T，人T）
	// 公司=0,部T=1,人T=2
	if (!sysManageScope.containsKey(pk_org)) {
	    manageScope = SysInitQuery.getParaInt(pk_org, "TBMOTLMTBY");
	    sysManageScope.put(pk_org, manageScope);
	}

	manageScope = sysManageScope.get(pk_org);
	int chkScope = -1;
	if (manageScope == 0) {
	    // 取公司O置
	    HRHROrgVO hrorg = (HRHROrgVO) this.getBaseDao().retrieveByPK(HRHROrgVO.class, pk_org);
	    if (hrorg != null) {
		if (hrorg.getAttributeValue("otchkscope") != null) {
		    chkScope = (int) hrorg.getAttributeValue("otchkscope");
		}
	    }
	} else if (manageScope == 1) {
	    // 取部TO置
	    Collection<PsnJobVO> psnjobs = this.getBaseDao().retrieveByClause(PsnJobVO.class,
		    "pk_psndoc='" + pk_psndoc + "' and endflag='N' and lastflag='Y' and dr=0");
	    PsnJobVO[] psnJobVOs = psnjobs.toArray(new PsnJobVO[0]);
	    HRDeptVO deptVO = (HRDeptVO) this.getBaseDao().retrieveByPK(HRDeptVO.class, psnJobVOs[0].getPk_dept());
	    if (deptVO.getAttributeValue("otchkscope") != null) {
		chkScope = (int) deptVO.getAttributeValue("otchkscope");

	    }
	} else if (manageScope == 2) {
	    // 取T工O置
	    if (!psndocMap.containsKey(pk_psndoc)) {
		PsndocVO psndoc = (PsndocVO) this.getBaseDao().retrieveByPK(PsndocVO.class, pk_psndoc);
		psndocMap.put(pk_psndoc, psndoc);
	    }
	    if (psndocMap.get(pk_psndoc).getAttributeValue("otchkscope") != null) {
		chkScope = (int) psndocMap.get(pk_psndoc).getAttributeValue("otchkscope");
	    }
	}

	if (chkScope == 1) {
	    return OvertimeLimitScopeEnum.ONEMONTH;
	} else if (chkScope == 2) {
	    return OvertimeLimitScopeEnum.THREEMONTH;
	}

	throw new BusinessException("o法找到T工的加班上限y");
    }

    @Override
    public Map<String, UFDouble[]> settleByFixSalary(Map<String, UFDouble> psnFixSalary, UFLiteralDate startDate,
	    UFLiteralDate endDate) throws BusinessException {
	// TODO 自赢a生的方法 Stub
	return null;
    }

    @Override
    public Map<String, UFDouble> calculateTaxFreeAmountByPeriod(String pk_org, String[] pk_psndocs, String cyear,
	    String cperiod) throws BusinessException {
	PeriodVO period = getPeriodService().queryByYearMonth(pk_org, cyear, cperiod);

	Map<String, UFDouble[]> taxAmounts = calculateTaxableByDate(pk_org, pk_psndocs, period.getBegindate(),
		period.getEnddate(), null);

	Map<String, UFDouble> ret = new HashMap<String, UFDouble>();
	if (taxAmounts != null && taxAmounts.size() > 0) {
	    for (Entry<String, UFDouble[]> amount : taxAmounts.entrySet()) {
		ret.put(amount.getKey(), amount.getValue()[0]);
	    }
	}
	return ret;
    }

    @Override
    public Map<String, UFDouble> calculateTaxableAmountByPeriod(String pk_org, String[] pk_psndocs, String cyear,
	    String cperiod) throws BusinessException {
	PeriodVO period = getPeriodService().queryByYearMonth(pk_org, cyear, cperiod);

	Map<String, UFDouble[]> taxAmounts = calculateTaxableByDate(pk_org, pk_psndocs, period.getBegindate(),
		period.getEnddate(), null);

	Map<String, UFDouble> ret = new HashMap<String, UFDouble>();
	if (taxAmounts != null && taxAmounts.size() > 0) {
	    for (Entry<String, UFDouble[]> amount : taxAmounts.entrySet()) {
		ret.put(amount.getKey(), amount.getValue()[1]);
	    }
	}
	return ret;
    }

    @Override
    public Map<String, UFDouble> getHoursToRestByScope(UFLiteralDate startDate, UFLiteralDate endDate,
	    String[] pk_psndocs) throws BusinessException {
	return getSegDetailSummary(pk_psndocs, startDate, endDate, SegDetailVO.HOURSTOREST);
    }

    @Override
    public Map<String, UFDouble> getHoursToRestByPeriod(String pk_org, String cyear, String cperiod, String[] pk_psndocs)
	    throws BusinessException {
	Map<String, UFDouble> ret = new HashMap<String, UFDouble>();
	if (pk_psndocs != null && pk_psndocs.length > 0) {
	    PeriodVO period = getPeriodService().queryByYearMonth(pk_org, cyear, cperiod);

	    if (period != null) {
		ret = getHoursToRestByScope(period.getBegindate(), period.getEnddate(), pk_psndocs);
	    }
	}
	return ret;
    }

    @Override
    public Map<String, Map<QueryValueTypeEnum, UFDouble>> getOvertimeHours(String pk_org, String[] pk_psndocs,
	    UFLiteralDate overtimeDate) throws BusinessException {
	Map<String, Map<QueryValueTypeEnum, UFDouble>> ret = new HashMap<String, Map<QueryValueTypeEnum, UFDouble>>();

	if (pk_psndocs != null) {
	    for (String pk_psndoc : pk_psndocs) {
		OTSChainNode curNode = OTSChainUtils.buildChainNodes(pk_psndoc, overtimeDate, null, false, true, true,
			false, true);

		UFDouble normalHours = UFDouble.ZERO_DBL;
		UFDouble offdayHours = UFDouble.ZERO_DBL;
		UFDouble holidayHours = UFDouble.ZERO_DBL;
		UFDouble nationalHours = UFDouble.ZERO_DBL;
		UFDouble totalFee = UFDouble.ZERO_DBL;

		while (curNode != null) {
		    if (curNode.getNodeData().getPk_org().equals(pk_org)) {
			SegRuleVO rule = (SegRuleVO) this.getBaseDao().retrieveByPK(SegRuleVO.class,
				curNode.getNodeData().getPk_segrule());
			if (CalendarDateTypeEnum.HOLIDAY.toIntValue() == rule.getDatetype()) {
			    // 例假日
			    holidayHours = holidayHours.add(curNode.getNodeData().getRemainhours());
			} else if (CalendarDateTypeEnum.OFFDAY.toIntValue() == rule.getDatetype()) {
			    // 休息日
			    offdayHours = offdayHours.add(curNode.getNodeData().getRemainhours());
			} else if (CalendarDateTypeEnum.NORMAL.toIntValue() == rule.getDatetype()) {
			    // 平日
			    normalHours = normalHours.add(curNode.getNodeData().getRemainhours());
			} else if (CalendarDateTypeEnum.NATIONALDAY.toIntValue() == rule.getDatetype()) {
			    // 定假日
			    nationalHours = nationalHours.add(curNode.getNodeData().getRemainhours());
			}
			totalFee = totalFee.add(curNode.getNodeData().getRemainamount());
		    }
		    curNode = curNode.getNextNode();
		}

		Map<QueryValueTypeEnum, UFDouble> hoursMap = new HashMap<QueryValueTypeEnum, UFDouble>();
		hoursMap.put(QueryValueTypeEnum.HOLIDAY, holidayHours);
		hoursMap.put(QueryValueTypeEnum.OFFDAY, offdayHours);
		hoursMap.put(QueryValueTypeEnum.NATIONALDAY, nationalHours);
		hoursMap.put(QueryValueTypeEnum.NORMAL, normalHours);
		hoursMap.put(QueryValueTypeEnum.ALL, holidayHours.add(offdayHours).add(nationalHours).add(normalHours));
		hoursMap.put(QueryValueTypeEnum.TOTALFEE, totalFee);
		ret.put(pk_psndoc, hoursMap);
	    }
	}
	return ret;
    }

    public BaseDAO getBaseDao() {
	if (baseDao == null) {
	    baseDao = new BaseDAO();
	}
	return baseDao;
    }

    public IPeriodQueryService getPeriodService() {
	if (periodService == null) {
	    periodService = (IPeriodQueryService) NCLocator.getInstance().lookup(IPeriodQueryService.class);
	}
	return periodService;
    }

    public Map<String, OTSChainNode> getAllNode() {
	if (allNode == null) {
	    allNode = new HashMap<String, OTSChainNode>();
	}
	return allNode;
    }

    @Override
    public Map<String, UFDouble> getOvertimeHoursByType(String pk_org, String[] pk_psndocs, UFLiteralDate overtimeDate,
	    String pk_overtimetype) throws BusinessException {
	return getOvertimeHours(pk_org, pk_psndocs, overtimeDate, pk_overtimetype, false);
    }

    @Override
    public Map<String, UFDouble> getOvertimeToRestHoursByType(String pk_org, String[] pk_psndocs,
	    UFLiteralDate overtimeDate, String pk_overtimetype) throws BusinessException {
	return getOvertimeHours(pk_org, pk_psndocs, overtimeDate, pk_overtimetype, true);
    }

    private Map<String, UFDouble> getOvertimeHours(String pk_org, String[] pk_psndocs, UFLiteralDate overtimeDate,
	    String pk_overtimetype, boolean isToRest) throws BusinessException {
	Map<String, UFDouble> ret = new HashMap<String, UFDouble>();
	if (pk_psndocs != null && pk_psndocs.length > 0) {
	    for (String pk_psndoc : pk_psndocs) {
		OTSChainNode curNode = OTSChainUtils.buildChainNodes(pk_psndoc, overtimeDate, null, isToRest, false,
			true, true, true);
		UFDouble otHours = UFDouble.ZERO_DBL;
		Map<String, String> pkTypes = new HashMap<String, String>();
		if (curNode != null) {
		    while (curNode != null) {
			// 前cr挡榭眨前c明榭盏模即樽钺嵋淮芜M入
			if (curNode.getNodeData() != null) {
			    if (!pkTypes.containsKey(curNode.getNodeData().getPk_overtimereg())) {
				OvertimeRegVO otvo = (OvertimeRegVO) this.getBaseDao().retrieveByPK(
					OvertimeRegVO.class, curNode.getNodeData().getPk_overtimereg());
				if (otvo != null) {
				    pkTypes.put(otvo.getPk_overtimereg(), otvo.getPk_overtimetype());
				}
			    }

			    if (pkTypes.containsKey(curNode.getNodeData().getPk_overtimereg())) {
				if (pk_overtimetype.equals(pkTypes.get(curNode.getNodeData().getPk_overtimereg()))) {
				    otHours = otHours.add(curNode.getNodeData().getHours());
				}
			    }
			}
			curNode = curNode.getNextNode();
		    }
		}
		ret.put(pk_psndoc, otHours);
	    }
	}
	return ret;
    }

    @Override
    public Map<String, UFDouble> getOvertimeTaxfreeAmount(String[] pk_psndocs, UFLiteralDate startDate,
	    UFLiteralDate endDate) throws BusinessException {
	return getSegDetailSummary(pk_psndocs, startDate, endDate, SegDetailVO.REMAINAMOUNTTAXFREE);
    }

    @Override
    public Map<String, UFDouble> getOvertimeTaxableAmount(String[] pk_psndocs, UFLiteralDate startDate,
	    UFLiteralDate endDate) throws BusinessException {
	return getSegDetailSummary(pk_psndocs, startDate, endDate, SegDetailVO.REMAINAMOUNTTAXABLE);
    }

    private Map<String, UFDouble> getSegDetailSummary(String[] pk_psndocs, UFLiteralDate startDate,
	    UFLiteralDate endDate, String digitPropName) throws BusinessException {
	Map<String, UFDouble> ret = new HashMap<String, UFDouble>();
	if (pk_psndocs != null && pk_psndocs.length > 0) {
	    for (String pk_psndoc : pk_psndocs) {
		UFLiteralDate overtimeDate = startDate;
		OTSChainNode curNode = OTSChainUtils.buildChainNodes(pk_psndoc, overtimeDate, null, false, false, true,
			true, true);
		if (curNode != null) {
		    while (curNode != null) {
			// 前c不榭眨前c明榭盏模即樽钺嵋淮芜M入
			if (curNode.getNodeData() != null) {
			    if ((curNode.getNodeData().getRegdate().isSameDate(overtimeDate) || curNode.getNodeData()
				    .getRegdate().after(overtimeDate))
				    && curNode.getNodeData().getRegdate().isSameDate(endDate)
				    || curNode.getNodeData().getRegdate().before(endDate)) {
				if (!ret.containsKey(pk_psndoc)) {
				    ret.put(pk_psndoc, UFDouble.ZERO_DBL);
				}

				// 重新取考勤r薪
				UFDouble hourpay = getPsnHourPay(pk_psndoc, curNode.getNodeData().getRegdate(),
					DaySalaryEnum.TBMHOURSALARY);
				// c已考勤r薪不同r重新算剩余加班M金~
				if (!hourpay.equals(curNode.getNodeData().getHourlypay())) {
				    curNode.getNodeData().setRemainamounttaxfree(
					    this.getOTAmount(curNode.getNodeData().getTaxfreerate(), hourpay, curNode
						    .getNodeData().getRemainhourstaxfree(), null, -1));
				    curNode.getNodeData().setRemainamounttaxable(
					    this.getOTAmount(curNode.getNodeData().getTaxablerate(), hourpay, curNode
						    .getNodeData().getRemainhourstaxable(), null, -1));
				    curNode.getNodeData().setRemainamount(
					    curNode.getNodeData().getRemainamounttaxfree()
						    .add(curNode.getNodeData().getRemainamounttaxable()));
				    OTSChainUtils.save(curNode);
				}

				ret.get(pk_psndoc)
					.add(curNode.getNodeData().getAttributeValue(digitPropName) == null ? UFDouble.ZERO_DBL
						: (UFDouble) curNode.getNodeData().getAttributeValue(digitPropName));
			    }
			}
			curNode = curNode.getNextNode();
		    }
		}
	    }
	}
	return ret;
    }

    @Override
    public MonthStatOTCalcVO[] getOvertimeSalaryHoursByTBMPeriodSource(String pk_org, String[] pk_psndocs,
	    String cyear, String cperiod, CalendarDateTypeEnum dateType, OvertimeSettleTypeEnum settleType)
	    throws BusinessException {
	List<MonthStatOTCalcVO> ret = new ArrayList<MonthStatOTCalcVO>();
	if (pk_psndocs != null && pk_psndocs.length > 0) {
	    PeriodVO period = getPeriodService().queryByYearMonth(pk_org, cyear, cperiod);
	    for (String pk_psndoc : pk_psndocs) {
		List<MonthStatOTCalcVO> vos = getCurrentMonthSalaryHoursByDate(pk_psndoc, period.getBegindate(),
			period.getEnddate(), dateType, settleType);
		for (MonthStatOTCalcVO vo : vos) {
		    vo.setPk_org(pk_org);
		    vo.setCyear(cyear);
		    vo.setCperiod(cperiod);
		    vo.setPk_psndoc(pk_psndoc);
		}
		ret.addAll(vos);
	    }
	}
	return ret.toArray(new MonthStatOTCalcVO[0]);
    }

    private List<MonthStatOTCalcVO> getCurrentMonthSalaryHoursByDate(String pk_psndoc, UFLiteralDate beginDate,
	    UFLiteralDate endDate, CalendarDateTypeEnum dateType, OvertimeSettleTypeEnum settleType)
	    throws BusinessException {
	List<MonthStatOTCalcVO> vos = new ArrayList<MonthStatOTCalcVO>();

	OTSChainNode curNode = OTSChainUtils.buildChainNodes(pk_psndoc, null, null, false, false, true, true, true);

	Map<OvertimeSettleTypeEnum, UFDouble> workDayAmount = new HashMap<OvertimeSettleTypeEnum, UFDouble>(); // 平日
	Map<OvertimeSettleTypeEnum, UFDouble> holidayAmount = new HashMap<OvertimeSettleTypeEnum, UFDouble>(); // 例假日
	Map<OvertimeSettleTypeEnum, UFDouble> offdayAmount = new HashMap<OvertimeSettleTypeEnum, UFDouble>();// 休息日
	Map<OvertimeSettleTypeEnum, UFDouble> nationalDayAmount = new HashMap<OvertimeSettleTypeEnum, UFDouble>();// 国假
	Map<OvertimeSettleTypeEnum, UFDouble> totalWorkAmount = new HashMap<OvertimeSettleTypeEnum, UFDouble>();// 平日合计
	Map<OvertimeSettleTypeEnum, UFDouble> totalHolidayAmount = new HashMap<OvertimeSettleTypeEnum, UFDouble>();// 例假日合计
	Map<OvertimeSettleTypeEnum, UFDouble> totalOffdayAmount = new HashMap<OvertimeSettleTypeEnum, UFDouble>();// 休息日合计
	Map<OvertimeSettleTypeEnum, UFDouble> totalNationalDayAmount = new HashMap<OvertimeSettleTypeEnum, UFDouble>();// 国假合计

	if (curNode != null) {
	    Map<String, SegRuleVO> ruleMap = new HashMap<String, SegRuleVO>();
	    while (curNode != null) {
		// 前c不榭眨前c明榭盏模即樽钺嵋淮芜M入
		if (curNode.getNodeData() != null) {
		    String pk_segrule = curNode.getNodeData().getPk_segrule();
		    // 加班日期在期间内
		    if (!curNode.getNodeData().getRegdate().after(endDate)
			    && !curNode.getNodeData().getRegdate().before(beginDate)) {
			if (!ruleMap.containsKey(pk_segrule)) {
			    // 缓存加班分段依据
			    ruleMap.put(pk_segrule,
				    (SegRuleVO) this.getBaseDao().retrieveByPK(SegRuleVO.class, pk_segrule));
			}

			if (dateType != null) {
			    if (CalendarDateTypeEnum.NORMAL.equals(dateType)) {
				// 统计平日
				addInPeriodAmount(dateType, curNode, workDayAmount, ruleMap, pk_segrule);
			    } else if (CalendarDateTypeEnum.HOLIDAY.equals(dateType)) {
				// 统计例假日
				addInPeriodAmount(dateType, curNode, holidayAmount, ruleMap, pk_segrule);
			    } else if (CalendarDateTypeEnum.OFFDAY.equals(dateType)) {
				// 统计休息日
				addInPeriodAmount(dateType, curNode, offdayAmount, ruleMap, pk_segrule);
			    } else if (CalendarDateTypeEnum.NATIONALDAY.equals(dateType)) {
				// 统计国假
				addInPeriodAmount(dateType, curNode, nationalDayAmount, ruleMap, pk_segrule);
			    }
			} else {
			    // 统计平日
			    addInPeriodAmount(CalendarDateTypeEnum.NORMAL, curNode, workDayAmount, ruleMap, pk_segrule);
			    // 统计例假日
			    addInPeriodAmount(CalendarDateTypeEnum.HOLIDAY, curNode, holidayAmount, ruleMap, pk_segrule);
			    // 统计休息日
			    addInPeriodAmount(CalendarDateTypeEnum.OFFDAY, curNode, offdayAmount, ruleMap, pk_segrule);
			    // 统计国假
			    addInPeriodAmount(CalendarDateTypeEnum.NATIONALDAY, curNode, nationalDayAmount, ruleMap,
				    pk_segrule);
			}
		    }
		    // 审核日期在范围内
		    else if (!curNode.getNodeData().getApproveddate().after(endDate)
			    && !curNode.getNodeData().getApproveddate().before(beginDate)) {
			if (dateType != null && !curNode.getNodeData().getIscompensation().booleanValue()) {
			    if (CalendarDateTypeEnum.NORMAL.equals(dateType)) {
				// 统计平日
				addInMap(workDayAmount, OvertimeSettleTypeEnum.OTHER_TOSALARY, curNode.getNodeData()
					.getRemainhours());
			    } else if (CalendarDateTypeEnum.HOLIDAY.equals(dateType)) {
				// 统计例假日
				addInMap(holidayAmount, OvertimeSettleTypeEnum.OTHER_TOSALARY, curNode.getNodeData()
					.getRemainhours());
			    } else if (CalendarDateTypeEnum.OFFDAY.equals(dateType)) {
				// 统计休息日
				addInMap(offdayAmount, OvertimeSettleTypeEnum.OTHER_TOSALARY, curNode.getNodeData()
					.getRemainhours());
			    } else if (CalendarDateTypeEnum.NATIONALDAY.equals(dateType)) {
				// 统计国假
				addInMap(nationalDayAmount, OvertimeSettleTypeEnum.OTHER_TOSALARY, curNode
					.getNodeData().getRemainhours());
			    }
			} else {
			    if (!curNode.getNodeData().getIscompensation().booleanValue()) {
				// 统计平日
				addInMap(workDayAmount, OvertimeSettleTypeEnum.OTHER_TOSALARY, curNode.getNodeData()
					.getRemainhours());
				// 统计例假日
				addInMap(holidayAmount, OvertimeSettleTypeEnum.OTHER_TOSALARY, curNode.getNodeData()
					.getRemainhours());
				// 统计休息日
				addInMap(offdayAmount, OvertimeSettleTypeEnum.OTHER_TOSALARY, curNode.getNodeData()
					.getRemainhours());
				// 统计国假
				addInMap(nationalDayAmount, OvertimeSettleTypeEnum.OTHER_TOSALARY, curNode
					.getNodeData().getRemainhours());
			    }
			}
		    } else {
			// 超过截止时间即为结束
			break;
		    }
		}
		curNode = curNode.getNextNode();
	    }

	    // 处理合计
	    // 平日
	    addInMap(totalWorkAmount, OvertimeSettleTypeEnum.TOTAL,
		    workDayAmount.get(OvertimeSettleTypeEnum.PERIOD_TOSALARY));
	    addInMap(totalWorkAmount, OvertimeSettleTypeEnum.TOTAL,
		    workDayAmount.get(OvertimeSettleTypeEnum.PERIOD_TOREST));
	    addInMap(totalWorkAmount, OvertimeSettleTypeEnum.TOTAL,
		    workDayAmount.get(OvertimeSettleTypeEnum.OTHER_TOSALARY));
	    // 例假日
	    addInMap(totalHolidayAmount, OvertimeSettleTypeEnum.TOTAL,
		    holidayAmount.get(OvertimeSettleTypeEnum.PERIOD_TOSALARY));
	    addInMap(totalHolidayAmount, OvertimeSettleTypeEnum.TOTAL,
		    holidayAmount.get(OvertimeSettleTypeEnum.PERIOD_TOREST));
	    addInMap(totalHolidayAmount, OvertimeSettleTypeEnum.TOTAL,
		    holidayAmount.get(OvertimeSettleTypeEnum.OTHER_TOSALARY));
	    // 休息日
	    addInMap(totalOffdayAmount, OvertimeSettleTypeEnum.TOTAL,
		    offdayAmount.get(OvertimeSettleTypeEnum.PERIOD_TOSALARY));
	    addInMap(totalOffdayAmount, OvertimeSettleTypeEnum.TOTAL,
		    offdayAmount.get(OvertimeSettleTypeEnum.PERIOD_TOREST));
	    addInMap(totalOffdayAmount, OvertimeSettleTypeEnum.TOTAL,
		    offdayAmount.get(OvertimeSettleTypeEnum.OTHER_TOSALARY));
	    // 国假
	    addInMap(totalNationalDayAmount, OvertimeSettleTypeEnum.TOTAL,
		    nationalDayAmount.get(OvertimeSettleTypeEnum.PERIOD_TOSALARY));
	    addInMap(totalNationalDayAmount, OvertimeSettleTypeEnum.TOTAL,
		    nationalDayAmount.get(OvertimeSettleTypeEnum.PERIOD_TOREST));
	    addInMap(totalNationalDayAmount, OvertimeSettleTypeEnum.TOTAL,
		    nationalDayAmount.get(OvertimeSettleTypeEnum.OTHER_TOSALARY));
	}

	convertToVO(vos, CalendarDateTypeEnum.NORMAL, workDayAmount);
	convertToVO(vos, CalendarDateTypeEnum.HOLIDAY, holidayAmount);
	convertToVO(vos, CalendarDateTypeEnum.OFFDAY, offdayAmount);
	convertToVO(vos, CalendarDateTypeEnum.NATIONALDAY, nationalDayAmount);

	convertToVO(vos, CalendarDateTypeEnum.NORMAL, totalWorkAmount);
	convertToVO(vos, CalendarDateTypeEnum.HOLIDAY, totalHolidayAmount);
	convertToVO(vos, CalendarDateTypeEnum.OFFDAY, totalOffdayAmount);
	convertToVO(vos, CalendarDateTypeEnum.NATIONALDAY, totalNationalDayAmount);

	return vos;
    }

    private void convertToVO(List<MonthStatOTCalcVO> vos, CalendarDateTypeEnum dateType,
	    Map<OvertimeSettleTypeEnum, UFDouble> amountMap) {
	for (Entry<OvertimeSettleTypeEnum, UFDouble> amount : amountMap.entrySet()) {
	    MonthStatOTCalcVO vo = new MonthStatOTCalcVO();
	    vo.setSettleType(amount.getKey());
	    vo.setHours(amount.getValue());
	    vo.setDateType(dateType);
	    vos.add(vo);
	}
    }

    private void addInPeriodAmount(CalendarDateTypeEnum dateType, OTSChainNode curNode,
	    Map<OvertimeSettleTypeEnum, UFDouble> workDayAmount, Map<String, SegRuleVO> ruleMap, String pk_segrule) {
	if (ruleMap.get(pk_segrule).getDatetype() == dateType.toIntValue()) {
	    if (!curNode.getNodeData().getIscompensation().booleanValue()) {
		// 本期转薪
		addInMap(workDayAmount, OvertimeSettleTypeEnum.PERIOD_TOSALARY, curNode.getNodeData().getRemainhours());
	    } else {
		// 本期转休
		addInMap(workDayAmount, OvertimeSettleTypeEnum.PERIOD_TOSALARY, curNode.getNodeData().getRemainhours());
	    }
	}
    }

    private void addInMap(Map<OvertimeSettleTypeEnum, UFDouble> dataMap, OvertimeSettleTypeEnum key, UFDouble value) {
	if (!dataMap.containsKey(key)) {
	    dataMap.put(key, UFDouble.ZERO_DBL);
	}

	dataMap.put(key, dataMap.get(key).add(value == null ? UFDouble.ZERO_DBL : value));
    }
}
