package nc.pubimpl.ta.overtime;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import nc.bs.dao.BaseDAO;
import nc.impl.ta.overtime.SegdetailMaintainImpl;
import nc.vo.pub.BusinessException;
import nc.vo.pub.lang.UFDouble;
import nc.vo.pub.lang.UFLiteralDate;
import nc.vo.ta.overtime.AggSegDetailVO;
import nc.vo.ta.overtime.SegDetailConsumeVO;
import nc.vo.ta.overtime.SegDetailVO;
import nc.vo.ta.overtime.SegRuleTermVO;

import org.apache.commons.lang.StringUtils;

/**
 * 加班分段明p向表工具
 * 
 * @author ssx
 * 
 */
public class OTSChainUtils {
    private static BaseDAO baseDAO = null;
    protected static String SPLT = "::";

    /**
     * 根人T及加班e建F有建表
     * 
     * @param pk_psndoc
     *            人TPK
     * @param otDate
     *            加班日期
     * @param pk_overtimereg
     *            加班登PK
     * @param isForceComp
     *            是否只建立D{休，Truer只建立D{休的c
     * @param isNoComp
     *            是否只建立非D{休，Truer建立除D{休以外其他c
     * @param isForceNotCancel
     *            是否只建立未作U，Truer只建立未作U的c
     * @param isForceNotConsumeFinished
     *            是否只建立未核N完的，Truer只建立未核N完的c
     * @param isForceSettled
     *            是否只建立未Y算的，Truer只建立未Y算的c
     * @return 表^c
     * 
     * @throws BusinessException
     */
    @SuppressWarnings("unchecked")
    public static OTSChainNode buildChainNodes(String pk_psndoc, UFLiteralDate otDate, String pk_overtimereg,
	    boolean isForceComp, boolean isNoComp, boolean isForceNotCancel, boolean isForceNotConsumeFinished,
	    boolean isForceSettled) throws BusinessException {
	// 按人T取全c
	Collection<SegDetailVO> sdList = getBaseDAO().retrieveByClause(
		SegDetailVO.class,
		"dr=0 and pk_psndoc='" + pk_psndoc + "' "
			+ (otDate == null ? "" : " and regdate='" + otDate.toString() + "'")
			+ (StringUtils.isEmpty(pk_overtimereg) ? "" : " and pk_overtimereg='" + pk_overtimereg + "'"),
		"nodeno");

	OTSChainNode firstNode = null;
	List<String> pkList = new ArrayList<String>();
	if (sdList != null && sdList.size() > 0) {
	    for (SegDetailVO vo : sdList) {
		// 查找第一c
		if (vo.getPk_parentsegdetail() == null || !existsParent(vo, sdList)) {
		    firstNode = new OTSChainNode();
		    firstNode.setNodeData(vo);
		    firstNode.setNextNode(null);
		    firstNode.setPriorNode(null);
		    pkList.add(vo.getPk_segdetail());
		}
	    }

	    if (firstNode != null) {
		OTSChainNode curNode = firstNode;
		// 建表
		for (SegDetailVO vo : sdList) {
		    if (!pkList.contains(vo.getPk_segdetail())) {
			SegDetailVO childVO = getChildVO(sdList, curNode.getNodeData().getPk_segdetail());
			if (childVO != null) {
			    OTSChainNode newNode = new OTSChainNode();
			    newNode.setNodeData(childVO);
			    appendNode(curNode, newNode);
			    curNode = newNode;
			} else {
			    break; // 一旦找不到子c，J殒表已建立完
			}

			pkList.add(vo.getPk_segdetail());
		    }
		}
	    }
	}

	// 如果有^Vl件
	if (isForceComp || isForceNotCancel || isForceNotConsumeFinished || isForceSettled) {
	    firstNode = filterNodes(isForceComp, isNoComp, isForceNotCancel, isForceNotConsumeFinished, isForceSettled,
		    firstNode);
	}

	return firstNode;
    }

    /**
     * 按奈锢礞表中^V出表
     * 
     * @param isForceComp
     *            是否只建立D{休，Truer只建立D{休的c
     * @param isNoComp
     *            是否只建立非D{休，Truer建立除D{休外其他所有c
     * @param isForceNotCancel
     *            是否只建立未作U，Truer只建立未作U的c
     * @param isForceNotConsumeFinished
     *            是否只建立未核N完的，Truer只建立未核N完的c
     * @param isForceSettled
     *            是否只建立未Y算的，Truer只建立未Y算的c
     * @param firstNode
     *            第一c
     * @return 第一c
     * @throws BusinessException
     */
    public static OTSChainNode filterNodes(boolean isForceComp, boolean isNoComp, boolean isForceNotCancel,
	    boolean isForceNotConsumeFinished, boolean isForceSettled, OTSChainNode firstNode) throws BusinessException {
	if (firstNode != null) {
	    OTSChainNode curNode = firstNode.clone(); // 克隆c，以免因改釉斐善渌表混y
	    while (curNode.getNextNode() != null) {
		OTSChainNode tmpNextNode = curNode.getNextNode();
		if ((isForceComp && !curNode.getNodeData().getIscompensation().booleanValue() // h除非加班D{休c
			)
			|| (isForceNotCancel && curNode.getNodeData().getIscanceled().booleanValue() // h除已作Uc
			) || (isForceNotConsumeFinished && curNode.getNodeData().getIsconsumed().booleanValue() // h除已核N完c
			) || (isForceSettled && curNode.getNodeData().getIssettled().booleanValue() // h除已Y算c
			) || (isNoComp && curNode.getNodeData().getIscompensation().booleanValue()) // h除D{休c
		) {
		    removeCurrentNode(curNode, false);
		}

		curNode = tmpNextNode;
	    }

	    firstNode = getFirstNode(curNode);
	}

	return firstNode;
    }

    /**
     * 取子c
     * 
     * @param sdList
     *            c列表
     * @param pk_segdetail
     *            前cPK
     * @return
     */
    private static SegDetailVO getChildVO(Collection<SegDetailVO> sdList, String pk_segdetail) {
	for (SegDetailVO vo : sdList) {
	    if (pk_segdetail.equals(vo.getPk_parentsegdetail())) {
		return vo;
	    }
	}
	return null;
    }

    /**
     * o定VO是否不存在上c
     * 
     * @param sdList
     *            全c
     * @param vo
     *            z查c
     * @return
     */
    private static boolean existsParent(SegDetailVO vo, Collection<SegDetailVO> sdList) {
	for (SegDetailVO childvo : sdList) {
	    if (vo.getPk_parentsegdetail().equals(childvo.getPk_segdetail())) {
		return true;
	    }
	}
	return false;
    }

    /**
     * 在指定c後增加c
     * 
     * @param targetNode
     *            目斯c
     * @param newNode
     *            新增c
     * @throws BusinessException
     */
    public static OTSChainNode appendNode(OTSChainNode targetNode, OTSChainNode newNode) throws BusinessException {
	if (targetNode != null) {
	    if (targetNode.getNextNode() != null) {
		if (newNode != null) {
		    newNode.setNextNode(targetNode.getNextNode());
		}
		targetNode.getNextNode().setPriorNode(newNode);
	    }
	    targetNode.setNextNode(newNode);
	    if (newNode != null) {
		newNode.setPriorNode(targetNode);
	    }
	    return targetNode;
	} else {
	    return newNode;
	}
    }

    /**
     * h除指定c的下一c
     * 
     * @param targetNode
     *            目斯c
     * @param removeFromDB
     *            是否熘h除
     * @throws BusinessException
     */
    public static void removeNextNode(OTSChainNode targetNode, boolean removeFromDB) throws BusinessException {
	if (targetNode != null) {
	    if (targetNode.getNextNode() != null) {
		removeCurrentNode(targetNode.getNextNode(), removeFromDB);
	    } else {
		throw new BusinessException("ch除e`：前c後已o後^c。");
	    }
	} else {
	    throw new BusinessException("ch除e`：目斯c榭铡");
	}
    }

    /**
     * h除指定c的前一c
     * 
     * @param targetNode
     *            目斯c
     * @param removeFromDB
     *            是否熘h除
     * @throws BusinessException
     */
    public static void removePriorNode(OTSChainNode targetNode, boolean removeFromDB) throws BusinessException {
	if (targetNode != null) {
	    if (targetNode.getPriorNode() != null) {
		removeCurrentNode(targetNode.getPriorNode(), removeFromDB);
	    } else {
		throw new BusinessException("ch除e`：前c後已o前mc。");
	    }
	} else {
	    throw new BusinessException("ch除e`：目斯c榭铡");
	}
    }

    /**
     * h除前c
     * 
     * @param targetNode
     *            前要h除的c
     * @param removeFromDB
     *            是否熘h除
     * @throws BusinessException
     */
    @SuppressWarnings("unchecked")
    public static void removeCurrentNode(OTSChainNode targetNode, boolean removeFromDB) throws BusinessException {
	if (targetNode.getPriorNode() != null) {
	    targetNode.getPriorNode().setNextNode(targetNode.getNextNode());
	}

	if (targetNode.getNextNode() != null) {
	    targetNode.getNextNode().setPriorNode(targetNode.getPriorNode());
	}

	if (removeFromDB) {
	    SegDetailVO vo = targetNode.getNodeData();
	    // h除
	    AggSegDetailVO aggvo = new AggSegDetailVO();
	    aggvo.setParent(vo);

	    Collection<SegDetailConsumeVO> lstChildVOs = getBaseDAO().retrieveByClause(SegDetailConsumeVO.class,
		    "pk_segdetail='" + vo.getPk_segdetail() + "'");
	    aggvo.setChildrenVO(lstChildVOs.toArray(new SegDetailConsumeVO[0]));
	    new SegdetailMaintainImpl().delete(new AggSegDetailVO[] { aggvo });
	}
    }

    /**
     * 根o定c查找第一c
     * 
     * @param node
     *            c
     * @return 第一c
     * @throws BusinessException
     */
    public static OTSChainNode getFirstNode(OTSChainNode node) throws BusinessException {
	if (node != null) {
	    if (node.getPriorNode() == null) {
		return node;
	    } else {
		return getFirstNode(node.getPriorNode());
	    }
	} else {
	    throw new BusinessException("@取第一ce`：前c不能榭铡");
	}
    }

    /**
     * 根o定的c查找最後一c
     * 
     * @param node
     *            c
     * @return 最後一c
     * @throws BusinessException
     */
    public static OTSChainNode getLastNode(OTSChainNode node) throws BusinessException {
	if (node != null) {
	    if (node.getNextNode() == null) {
		return node;
	    } else {
		return getLastNode(node.getNextNode());
	    }
	} else {
	    throw new BusinessException("@取最後一ce`：前c不能榭铡");
	}
    }

    /**
     * 保存所有c的加班分段明 （H用於SegDetailVOw的操作，不理消耗作I）
     * 
     * @param node
     *            c
     * @return
     * @throws BusinessException
     */
    public static OTSChainNode saveAll(OTSChainNode node) throws BusinessException {
	if (node != null) {
	    OTSChainNode curNode = getFirstNode(node);
	    do {
		if (curNode.getPriorNode() != null) {
		    curNode.getNodeData().setPk_parentsegdetail(curNode.getPriorNode().getNodeData().getPk_segdetail());
		} else {
		    curNode.getNodeData().setPk_parentsegdetail(null);
		}
		save(curNode);
		curNode = curNode.getNextNode();
	    } while (curNode != null);
	    return node;
	} else {
	    throw new BusinessException("全部保存e`：前c不能榭铡");
	}
    }

    /**
     * 喂c保存
     * 
     * @param node
     *            前保存的c
     * @throws BusinessException
     */
    @SuppressWarnings("unchecked")
    public static void save(OTSChainNode node) throws BusinessException {
	SegDetailVO vo = node.getNodeData();
	if (vo.getPk_segdetail() == null) {
	    // 新增
	    AggSegDetailVO aggvo = new AggSegDetailVO();
	    aggvo.setParent(vo);
	    AggSegDetailVO[] ret = new SegdetailMaintainImpl().insert(new AggSegDetailVO[] { aggvo });
	    vo.setPk_segdetail(ret[0].getPrimaryKey());
	} else {
	    // 修改
	    AggSegDetailVO aggvo = new AggSegDetailVO();
	    aggvo.setParent(vo);

	    Collection<SegDetailConsumeVO> lstChildVOs = getBaseDAO().retrieveByClause(SegDetailConsumeVO.class,
		    "pk_segdetail='" + vo.getPk_segdetail() + "'");
	    aggvo.setChildrenVO(lstChildVOs.toArray(new SegDetailConsumeVO[0]));
	    new SegdetailMaintainImpl().update(new AggSegDetailVO[] { aggvo });
	}
    }

    public static BaseDAO getBaseDAO() {
	if (baseDAO == null) {
	    baseDAO = new BaseDAO();
	}

	return baseDAO;
    }

    /**
     * 合愎c
     * 
     * @param originalNode
     *            原始c
     * @param newNode
     *            新c
     * @throws BusinessException
     */
    public static OTSChainNode combineNodes(OTSChainNode originalNode, OTSChainNode newNode) throws BusinessException {
	if (newNode != null) {
	    OTSChainNode curNode = null;
	    OTSChainNode parentNode = null;

	    // 按新c遍v
	    do {
		if (curNode == null) {
		    curNode = newNode;
		} else {
		    curNode = curNode.getNextNode();
		}

		// 查找父c
		// 基本：查找NodeCode相同（人T，日期，分段a都相同）的c
		// 或逆表末端往前回i，出F的第一NodeCode小於前NodeCode的c
		parentNode = findParentNode(originalNode, curNode);
		OTSChainNode addedNode = curNode.cloneSingle();
		if (parentNode == null) {
		    // 不存在父c，即表中所有c均比前cl生的晚，所以前c槭坠c
		    addedNode.setNextNode(null);
		    addedNode.setPriorNode(null);
		    originalNode = OTSChainUtils.appendNode(addedNode, originalNode);
		} else {
		    if (parentNode.getNodeData().getNodecode().equals(addedNode.getNodeData().getNodecode())) {
			OTSChainNode nextNewNode = null;
			// ca相同=假人T、日期、分段完全一
			UFDouble ruleHours = parentNode.getNodeData().getRulehours(); // 分段t定x的分段rL
			UFDouble parentHours = getParentTotalHoursBySameCode(parentNode); // 已子玫囊trL
			UFDouble newHours = addedNode.getNodeData().getHours();
			if (parentHours.doubleValue() < ruleHours.doubleValue()) {
			    // 父c加班rL小於分段rLr=上次假未M分段，z查分段nrL
			    if (parentHours.add(newHours).doubleValue() <= ruleHours.doubleValue()) {
				// n加後仍然小於等於分段rL的，直接增加後mc
				originalNode = appendNode(parentNode, addedNode);
			    } else {
				// n加後超^分段rL的，⒃鲅a本段rL的後mc
				UFDouble appendHours = ruleHours.sub(parentHours); // 未子玫囊trL
				UFDouble appendHoursTaxfree = UFDouble.ZERO_DBL;
				UFDouble appendHoursTaxable = UFDouble.ZERO_DBL;
				if (appendHours.doubleValue() >= addedNode.getNodeData().getHourstaxfree()
					.doubleValue()) {
				    appendHoursTaxfree = addedNode.getNodeData().getHourstaxfree();
				    if (appendHours.sub(appendHoursTaxfree).doubleValue() >= addedNode.getNodeData()
					    .getHourstaxable().doubleValue()) {
					appendHoursTaxable = addedNode.getNodeData().getHourstaxable();
				    } else {
					appendHoursTaxable = appendHours.sub(appendHoursTaxfree);
				    }
				} else {
				    appendHoursTaxfree = appendHours;
				    appendHoursTaxable = UFDouble.ZERO_DBL;
				}

				UFDouble nextHours = addedNode.getNodeData().getHours().sub(appendHours);
				UFDouble nextHoursTaxfree = addedNode.getNodeData().getHourstaxfree()
					.sub(appendHoursTaxfree);
				UFDouble nextHoursTaxable = addedNode.getNodeData().getHourstaxable()
					.sub(appendHoursTaxable);

				addedNode.getNodeData().setHours(appendHours);
				addedNode.getNodeData().setHourstaxfree(appendHoursTaxfree);
				addedNode.getNodeData().setHourstaxable(appendHoursTaxable);

				originalNode = appendNode(parentNode, addedNode);

				// 超^部分加班分估取後一段
				nextNewNode = getNextNewNode(addedNode, nextHours, nextHoursTaxfree, nextHoursTaxable);
				originalNode = combineNodes(originalNode, nextNewNode);
			    }
			} else if (parentHours.doubleValue() == ruleHours.doubleValue()) {
			    // 父c加班rL等於分段rL=直接在前c上增加後mc，加班分段要取後一段
			    nextNewNode = getNextNewNode(addedNode, addedNode.getNodeData().getHours(), addedNode
				    .getNodeData().getHourstaxfree(), addedNode.getNodeData().getHourstaxable());
			    originalNode = combineNodes(originalNode, nextNewNode);
			}
		    } else {
			// ca不相同，直接在前c上增加後mc
			originalNode = appendNode(parentNode, addedNode);
		    }
		}
	    } while ((curNode.getNextNode() != null));
	}

	return OTSChainUtils.getFirstNode(originalNode);
    }

    private static OTSChainNode getNextNewNode(OTSChainNode newNode, UFDouble nextHours, UFDouble nextHoursTaxfree,
	    UFDouble nextHoursTaxable) throws BusinessException {
	OTSChainNode nextNewNode;
	nextNewNode = newNode.cloneSingle();
	nextNewNode.setNextNode(null);
	nextNewNode.setPriorNode(null);
	nextNewNode.getNodeData().setHours(nextHours);
	nextNewNode.getNodeData().setHourstaxfree(nextHoursTaxfree);
	nextNewNode.getNodeData().setHourstaxable(nextHoursTaxable);
	nextNewNode.setNodeData(getNextSegRuleTerm(nextNewNode.getNodeData()));
	return nextNewNode;
    }

    @SuppressWarnings("unchecked")
    private static SegDetailVO getNextSegRuleTerm(SegDetailVO nodeData) throws BusinessException {
	SegDetailVO ret = nodeData;
	Collection<SegRuleTermVO> terms = getBaseDAO().retrieveByClause(SegRuleTermVO.class,
		"pk_segrule='" + nodeData.getPk_segrule() + "' and dr=0", "segno");

	if (terms == null || terms.size() == 0) {
	    throw new BusinessException("建新後mc失。何凑业揭言O定的分段t明");
	} else {
	    int count = 0;
	    boolean getThis = false;
	    SegRuleTermVO nextTerm = null;
	    for (SegRuleTermVO term : terms) {
		if (getThis) {
		    nextTerm = term;
		    break;
		}
		count++;
		if (term.getPk_segruleterm().equals(nodeData.getPk_segruleterm())) {
		    if (count == terms.size()) {
			nextTerm = term;
		    } else {
			getThis = true;
		    }
		}
	    }

	    UFDouble start = nextTerm.getStartpoint();
	    UFDouble end = nextTerm.getEndpoint();
	    UFDouble taxablerate = nextTerm.getTaxableotrate();
	    UFDouble taxfreerate = nextTerm.getTaxfreeotrate();
	    ret.setPk_segruleterm(nextTerm.getPk_segruleterm());
	    ret.setRulehours(end.sub(start));
	    ret.setTaxfreerate(taxfreerate);
	    ret.setTaxablerate(taxablerate);
	}
	return ret;
    }

    /**
     * 取所有上cCode完全一拥母骷父c加班r抵和
     * 
     * @param currentNode
     * @return
     */
    private static UFDouble getParentTotalHoursBySameCode(OTSChainNode currentNode) {
	UFDouble hours = currentNode.getNodeData().getHours();
	OTSChainNode curNode = currentNode;
	// 上c不榭眨且上c的ca=本次n加的ca
	while (curNode.getPriorNode() != null
		&& curNode.getPriorNode().getNodeData().getNodecode().equals(currentNode.getNodeData().getNodecode())) {
	    hours = hours.add(curNode.getPriorNode().getNodeData().getHours());
	    curNode = curNode.getPriorNode();
	}
	return hours;
    }

    /**
     * 查找父c
     * 
     * @param originalNode
     *            原始c表
     * @param checkNode
     *            z查c
     * @return
     * @throws BusinessException
     */
    private static OTSChainNode findParentNode(OTSChainNode originalNode, OTSChainNode checkNode)
	    throws BusinessException {
	if (originalNode == null) {
	    return null;
	}
	String checkedNodeCode = checkNode.getNodeData().getNodecode();
	String[] checkedCodeList = checkedNodeCode.split(SPLT);
	OTSChainNode retNode = null;
	OTSChainNode curNode = getLastNode(originalNode);
	do {
	    // 向上ふ业谝NodeCode相同或者早於z查c
	    String curNodeCode = curNode.getNodeData().getNodecode();
	    String[] curCodeList = curNodeCode.split(SPLT);
	    if (curNodeCode.equals(checkedNodeCode)
		    || (curCodeList[0].equals(checkedCodeList[0]) && (curCodeList[1] + curCodeList[3])
			    .compareTo(checkedCodeList[1] + checkedCodeList[3]) <= 0)) {
		retNode = curNode;
		break;
	    }
	    curNode = curNode.getPriorNode();
	} while (curNode.getPriorNode() != null);
	return retNode;
    }

    /**
     * 取所有c的加班分段明
     * 
     * @param node
     *            c
     * @return
     * @throws BusinessException
     */
    public static SegDetailVO[] getAllNodeData(OTSChainNode node) throws BusinessException {
	List<SegDetailVO> segDetailVOs = new ArrayList<SegDetailVO>();

	OTSChainNode curNode = getFirstNode(node);
	do {
	    segDetailVOs.add(curNode.getNodeData());
	    curNode = curNode.getNextNode();
	} while (curNode != null);

	return segDetailVOs.toArray(new SegDetailVO[0]);
    }
}
