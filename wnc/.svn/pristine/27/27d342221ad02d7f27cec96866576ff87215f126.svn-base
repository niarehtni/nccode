package nc.pubitf.ta.overtime;

import java.util.Map;

import nc.vo.pub.BusinessException;
import nc.vo.pub.lang.UFDouble;
import nc.vo.pub.lang.UFLiteralDate;
import nc.vo.ta.leave.LeaveRegVO;
import nc.vo.ta.overtime.OvertimeRegVO;

public interface ISegDetailService {
	/**
	 * ]约影喾侄蚊骷（批量）
	 * 
	 * I者：根o定的加班登ο蠹合，逐]约影喾侄蚊骷c 增加加班分段明r，父c的判啵盒§兜褥懂前ca的最近一c，
	 * 如新ca不存在，t新增c，K接原父c後mc（更新父cPK楫前父cPK的c之父cPK=然cPK）
	 * 
	 * @param overtimeRegVOs
	 *            加班登到M
	 * @throws BusinessException
	 */
	public void regOvertimeSegDetail(OvertimeRegVO[] overtimeRegVOs)
			throws BusinessException;

	/**
	 * ]约影喾侄魏虽N（批量）
	 * 
	 * I者：根o定的休假登ο蠹合，逐]约影喾侄魏虽N，
	 * 休假登]r，根SegDetailAggVO在\行r造Da休、未作U、未核N完成、未Y算、核N剩Nr>0的快捷L蜗蜴表（用於快速核N）
	 * 休假登保存rl生核N幼
	 * ，只核N加班D{休的，核Nr使用快捷L蜗蜴表按c序由小到大M行逐核N，K重新算已核Nr导敖痤~、核N剩Nr导敖痤~
	 * 、更新是否核N完成
	 * 
	 * 
	 * @param leaveRegVOs
	 *            休假登到M
	 * @throws BusinessException
	 */
	public void regOvertimeSegDetailConsume(LeaveRegVO[] leaveRegVOs)
			throws BusinessException;

	/**
	 * 按起迄rg算rg段加班r导加班薪Y（批量）
	 * 
	 * I者：根o定的T工及rg，以及考勤t上的加班一月/三月的限制，超限部分做加班M，限炔糠肿槊舛加班M返回
	 * 
	 * @param pk_psndocs
	 *            算T工到M
	 * @param startDate
	 *            _始日期
	 * @param endDate
	 *            Y束日期
	 * @return Map.Key=T工PK，Map.Value=UFDoube[0]:免加班M合金~，UFDouble[1]:加班M合金~
	 * @throws BusinessException
	 */
	Map<String, UFDouble[]> calculateTaxableByDate(String[] pk_psndocs,
			UFLiteralDate startDate, UFLiteralDate endDate)
			throws BusinessException;

	/**
	 * 按o定固定r薪及起迄rgY算（批量）
	 * 
	 * I者：根o定的T工r薪及rg，以及考勤t上的加班一月/三月的限制，超限部分做加班M，限炔糠肿槊舛加班M返回
	 * 
	 * @param psnFixSalary
	 *            T工固定r薪集合
	 * @param startDate
	 *            _始日期
	 * @param endDate
	 *            Y束日期
	 * @return Map.Key=T工PK，Map.Value=UFDoube[0]:免加班M合金~，UFDouble[1]:加班M合金~
	 * @throws BusinessException
	 */
	Map<String, UFDouble[]> settleByFixSalary(
			Map<String, UFDouble> psnFixSalary, UFLiteralDate startDate,
			UFLiteralDate endDate) throws BusinessException;

}
