package nc.pubimpl.ta.overtime;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import nc.bs.dao.BaseDAO;
import nc.impl.ta.overtime.SegdetailMaintainImpl;
import nc.vo.pub.BusinessException;
import nc.vo.pub.lang.UFDouble;
import nc.vo.pub.lang.UFLiteralDate;
import nc.vo.ta.overtime.AggSegDetailVO;
import nc.vo.ta.overtime.SegDetailConsumeVO;
import nc.vo.ta.overtime.SegDetailVO;
import nc.vo.ta.overtime.SegRuleTermVO;

import org.apache.commons.lang.StringUtils;

/**
 * 加班分段明p向表工具
 * 
 * @author ssx
 * 
 */
public class OTSChainUtils {
	private static BaseDAO baseDAO = null;

	/**
	 * 根人T及加班e建F有建表
	 * 
	 * @param pk_psndoc
	 *            人TPK
	 * @param otDate
	 *            加班日期
	 * @param pk_overtimereg
	 *            加班登PK
	 * @param isForceComp
	 *            是否只建立D{休，Truer只建立D{休的c
	 * @param isNoComp
	 *            是否只建立非D{休，Truer建立除D{休以外其他c
	 * @param isForceNotCancel
	 *            是否只建立未作U，Truer只建立未作U的c
	 * @param isForceNotConsumeFinished
	 *            是否只建立未核N完的，Truer只建立未核N完的c
	 * @param isForceSettled
	 *            是否只建立未Y算的，Truer只建立未Y算的c
	 * @return 表^c
	 * 
	 * @throws BusinessException
	 */
	@SuppressWarnings("unchecked")
	public static OTSChainNode buildChainNodes(String pk_psndoc,
			UFLiteralDate otDate, String pk_overtimereg, boolean isForceComp,
			boolean isNoComp, boolean isForceNotCancel,
			boolean isForceNotConsumeFinished, boolean isForceSettled)
			throws BusinessException {
		// 按人T取全c
		Collection<SegDetailVO> sdList = getBaseDAO().retrieveByClause(
				SegDetailVO.class,
				"dr=0 and pk_psndoc='"
						+ pk_psndoc
						+ "' "
						+ (otDate == null ? "" : " and regdate='"
								+ otDate.toString() + "'")
						+ (StringUtils.isEmpty(pk_overtimereg) ? ""
								: " and pk_overtimereg='" + pk_overtimereg
										+ "'"), "nodeno");

		OTSChainNode firstNode = null;
		List<String> pkList = new ArrayList<String>();
		if (sdList != null && sdList.size() > 0) {
			for (SegDetailVO vo : sdList) {
				// 查找第一c
				if (vo.getPk_parentsegdetail() == null
						|| !existsParent(vo, sdList)) {
					firstNode = new OTSChainNode();
					firstNode.setNodeData(vo);
					firstNode.setNextNode(null);
					firstNode.setPriorNode(null);
					pkList.add(vo.getPk_segdetail());
				}
			}

			if (firstNode != null) {
				OTSChainNode curNode = firstNode;
				// 建表
				for (SegDetailVO vo : sdList) {
					if (!pkList.contains(vo.pk_segdetail)) {
						SegDetailVO childVO = getChildVO(sdList, curNode
								.getNodeData().getPk_segdetail());
						if (childVO != null) {
							OTSChainNode newNode = new OTSChainNode();
							newNode.setNodeData(childVO);
							appendNode(curNode, newNode);
							curNode = newNode;
						} else {
							break; // 一旦找不到子c，J殒表已建立完
						}

						pkList.add(vo.getPk_segdetail());
					}
				}
			}
		}

		// 如果有^Vl件
		if (isForceComp || isForceNotCancel || isForceNotConsumeFinished
				|| isForceSettled) {
			firstNode = filterNodes(isForceComp, isNoComp, isForceNotCancel,
					isForceNotConsumeFinished, isForceSettled, firstNode);
		}

		return firstNode;
	}

	/**
	 * 按奈锢礞表中^V出表
	 * 
	 * @param isForceComp
	 *            是否只建立D{休，Truer只建立D{休的c
	 * @param isNoComp
	 *            是否只建立非D{休，Truer建立除D{休外其他所有c
	 * @param isForceNotCancel
	 *            是否只建立未作U，Truer只建立未作U的c
	 * @param isForceNotConsumeFinished
	 *            是否只建立未核N完的，Truer只建立未核N完的c
	 * @param isForceSettled
	 *            是否只建立未Y算的，Truer只建立未Y算的c
	 * @param firstNode
	 *            第一c
	 * @return 第一c
	 * @throws BusinessException
	 */
	public static OTSChainNode filterNodes(boolean isForceComp,
			boolean isNoComp, boolean isForceNotCancel,
			boolean isForceNotConsumeFinished, boolean isForceSettled,
			OTSChainNode firstNode) throws BusinessException {
		if (firstNode != null) {
			OTSChainNode curNode = firstNode.clone(); // 克隆c，以免因改釉斐善渌表混y
			while (curNode.getNextNode() != null) {
				OTSChainNode tmpNextNode = curNode.getNextNode();
				if ((isForceComp && !curNode.getNodeData().getIscompensation()
						.booleanValue() // h除非加班D{休c
				)
						|| (isForceNotCancel && curNode.getNodeData()
								.getIscanceled().booleanValue() // h除已作Uc
						)
						|| (isForceNotConsumeFinished && curNode.getNodeData()
								.getIsconsumed().booleanValue() // h除已核N完c
						)
						|| (isForceSettled && curNode.getNodeData()
								.getIssettled().booleanValue() // h除已Y算c
						)
						|| (isNoComp && curNode.getNodeData()
								.getIscompensation().booleanValue()) // h除D{休c
				) {
					removeCurrentNode(curNode, false);
				}

				curNode = tmpNextNode;
			}

			firstNode = getFirstNode(curNode);
		}

		return firstNode;
	}

	/**
	 * 取子c
	 * 
	 * @param sdList
	 *            c列表
	 * @param pk_segdetail
	 *            前cPK
	 * @return
	 */
	private static SegDetailVO getChildVO(Collection<SegDetailVO> sdList,
			String pk_segdetail) {
		for (SegDetailVO vo : sdList) {
			if (vo.getPk_parentsegdetail().equals(pk_segdetail)) {
				return vo;
			}
		}
		return null;
	}

	/**
	 * o定VO是否不存在上c
	 * 
	 * @param sdList
	 *            全c
	 * @param vo
	 *            z查c
	 * @return
	 */
	private static boolean existsParent(SegDetailVO vo,
			Collection<SegDetailVO> sdList) {
		for (SegDetailVO childvo : sdList) {
			if (vo.getPk_parentsegdetail().equals(childvo.getPk_segdetail())) {
				return true;
			}
		}
		return false;
	}

	/**
	 * 在指定c後增加c
	 * 
	 * @param targetNode
	 *            目斯c
	 * @param newNode
	 *            新增c
	 * @throws BusinessException
	 */
	public static void appendNode(OTSChainNode targetNode, OTSChainNode newNode)
			throws BusinessException {
		if (targetNode != null && newNode != null) {
			if (targetNode.getNextNode() != null) {
				newNode.setNextNode(targetNode.getNextNode());
				targetNode.getNextNode().setPriorNode(newNode);
			}
			targetNode.setNextNode(newNode);
			newNode.setPriorNode(targetNode);
		} else {
			throw new BusinessException("增加ce`：目斯c及前c都不能榭铡");
		}
	}

	/**
	 * h除指定c的下一c
	 * 
	 * @param targetNode
	 *            目斯c
	 * @param removeFromDB
	 *            是否熘h除
	 * @throws BusinessException
	 */
	public static void removeNextNode(OTSChainNode targetNode,
			boolean removeFromDB) throws BusinessException {
		if (targetNode != null) {
			if (targetNode.getNextNode() != null) {
				removeCurrentNode(targetNode.getNextNode(), removeFromDB);
			} else {
				throw new BusinessException("ch除e`：前c後已o後^c。");
			}
		} else {
			throw new BusinessException("ch除e`：目斯c榭铡");
		}
	}

	/**
	 * h除指定c的前一c
	 * 
	 * @param targetNode
	 *            目斯c
	 * @param removeFromDB
	 *            是否熘h除
	 * @throws BusinessException
	 */
	public static void removePriorNode(OTSChainNode targetNode,
			boolean removeFromDB) throws BusinessException {
		if (targetNode != null) {
			if (targetNode.getPriorNode() != null) {
				removeCurrentNode(targetNode.getPriorNode(), removeFromDB);
			} else {
				throw new BusinessException("ch除e`：前c後已o前mc。");
			}
		} else {
			throw new BusinessException("ch除e`：目斯c榭铡");
		}
	}

	/**
	 * h除前c
	 * 
	 * @param targetNode
	 *            前要h除的c
	 * @param removeFromDB
	 *            是否熘h除
	 * @throws BusinessException
	 */
	@SuppressWarnings("unchecked")
	public static void removeCurrentNode(OTSChainNode targetNode,
			boolean removeFromDB) throws BusinessException {
		if (targetNode.getPriorNode() != null) {
			targetNode.getPriorNode().setNextNode(targetNode.getNextNode());
		}

		if (targetNode.getNextNode() != null) {
			targetNode.getNextNode().setPriorNode(targetNode.getPriorNode());
		}

		if (removeFromDB) {
			SegDetailVO vo = targetNode.getNodeData();
			// h除
			AggSegDetailVO aggvo = new AggSegDetailVO();
			aggvo.setParent(vo);

			Collection<SegDetailConsumeVO> lstChildVOs = getBaseDAO()
					.retrieveByClause(SegDetailConsumeVO.class,
							"pk_segdetail='" + vo.getPk_segdetail() + "'");
			aggvo.setChildrenVO(lstChildVOs.toArray(new SegDetailConsumeVO[0]));
			new SegdetailMaintainImpl().delete(new AggSegDetailVO[] { aggvo });
		}
	}

	/**
	 * 根o定c查找第一c
	 * 
	 * @param node
	 *            c
	 * @return 第一c
	 * @throws BusinessException
	 */
	public static OTSChainNode getFirstNode(OTSChainNode node)
			throws BusinessException {
		if (node != null) {
			if (node.getPriorNode() == null) {
				return node;
			} else {
				return getFirstNode(node.getPriorNode());
			}
		} else {
			throw new BusinessException("@取第一ce`：前c不能榭铡");
		}
	}

	/**
	 * 根o定的c查找最後一c
	 * 
	 * @param node
	 *            c
	 * @return 最後一c
	 * @throws BusinessException
	 */
	public static OTSChainNode getLastNode(OTSChainNode node)
			throws BusinessException {
		if (node != null) {
			if (node.getNextNode() == null) {
				return node;
			} else {
				return getLastNode(node.getNextNode());
			}
		} else {
			throw new BusinessException("@取最後一ce`：前c不能榭铡");
		}
	}

	/**
	 * 保存所有c的加班分段明 （H用於SegDetailVOw的操作，不理消耗作I）
	 * 
	 * @param node
	 *            c
	 * @return
	 * @throws BusinessException
	 */
	public static OTSChainNode saveAll(OTSChainNode node)
			throws BusinessException {
		if (node != null) {
			OTSChainNode curNode = getFirstNode(node);
			do {
				save(curNode);
				curNode = curNode.getNextNode();
			} while (curNode != null);
			return node;
		} else {
			throw new BusinessException("全部保存e`：前c不能榭铡");
		}
	}

	/**
	 * 喂c保存
	 * 
	 * @param node
	 *            前保存的c
	 * @throws BusinessException
	 */
	@SuppressWarnings("unchecked")
	private static void save(OTSChainNode node) throws BusinessException {
		SegDetailVO vo = node.getNodeData();
		if (vo.getPk_segdetail() == null) {
			// 新增
			AggSegDetailVO aggvo = new AggSegDetailVO();
			aggvo.setParent(vo);
			new SegdetailMaintainImpl().insert(new AggSegDetailVO[] { aggvo });
		} else {
			// 修改
			AggSegDetailVO aggvo = new AggSegDetailVO();
			aggvo.setParent(vo);

			Collection<SegDetailConsumeVO> lstChildVOs = getBaseDAO()
					.retrieveByClause(SegDetailConsumeVO.class,
							"pk_segdetail='" + vo.getPk_segdetail() + "'");
			aggvo.setChildrenVO(lstChildVOs.toArray(new SegDetailConsumeVO[0]));
			new SegdetailMaintainImpl().update(new AggSegDetailVO[] { aggvo });
		}
	}

	public static BaseDAO getBaseDAO() {
		if (baseDAO == null) {
			baseDAO = new BaseDAO();
		}

		return baseDAO;
	}

	/**
	 * 合愎c
	 * 
	 * @param originalNode
	 *            原始c
	 * @param newNode
	 *            新c
	 * @throws BusinessException
	 */
	public static void combineNodes(OTSChainNode originalNode,
			OTSChainNode newNode) throws BusinessException {
		if (newNode != null) {
			OTSChainNode curNode = newNode;

			// 按新c遍v
			while (curNode.getNextNode() != null) {
				// 查找父c
				// 基本：查找NodeCode相同（人T，日期，分段a都相同）的c
				// 或逆表末端往前回i，出F的第一NodeCode小於前NodeCode的c
				OTSChainNode parentNode = findParentNode(originalNode, curNode);
				if (parentNode == null) {
					// 不存在父c，即表中所有c均比前cl生的晚，所以前c槭坠c
					OTSChainNode addedNode = curNode.clone();
					addedNode.setNextNode(null);
					addedNode.setPriorNode(null);
					OTSChainUtils.appendNode(addedNode, originalNode);
				} else {
					if (parentNode.getNodeData().nodecode.equals(curNode
							.getNodeData().getNodecode())) {
						OTSChainNode nextNewNode = null;
						// ca相同=假人T、日期、分段完全一
						UFDouble ruleHours = parentNode.getNodeData()
								.getRulehours(); // 分段t定x的分段rL
						UFDouble parentHours = getParentTotalHoursBySameCode(parentNode);
						UFDouble newHours = newNode.getNodeData().getHours();
						if (parentHours.doubleValue() < ruleHours.doubleValue()) {
							// 父c加班rL小於分段rLr=上次假未M分段，z查分段nrL
							if (parentHours.add(newHours).doubleValue() <= ruleHours
									.doubleValue()) {
								// n加後仍然小於等於分段rL的，直接增加後mc
								appendNode(parentNode, newNode);
							} else {
								// n加後超^分段rL的，⒃鲅a本段rL的增加後mc
								UFDouble appendHours = ruleHours
										.sub(parentHours);
								UFDouble nextHours = newNode.getNodeData()
										.getHours().sub(appendHours);
								newNode.getNodeData().setHours(appendHours);
								appendNode(parentNode, newNode);
								// 超^部分加班分估取後一段
								nextNewNode = getNextNewNode(newNode, nextHours);
								combineNodes(originalNode, nextNewNode);
							}
						} else if (parentHours.doubleValue() == ruleHours
								.doubleValue()) {
							// 父c加班rL等於分段rL=直接在前c上增加後mc，加班分段要取後一段
							nextNewNode = getNextNewNode(newNode, newNode
									.getNodeData().getHours());
							combineNodes(originalNode, nextNewNode);
						}
					} else {
						// ca不相同，直接在前c上增加後mc
						appendNode(parentNode, newNode);
					}
				}
				curNode = curNode.getNextNode();
			}
		}
	}

	private static OTSChainNode getNextNewNode(OTSChainNode newNode,
			UFDouble nextHours) throws BusinessException {
		OTSChainNode nextNewNode;
		nextNewNode = newNode.clone();
		nextNewNode.setNextNode(null);
		nextNewNode.setPriorNode(null);
		nextNewNode.getNodeData().setHours(nextHours);
		nextNewNode.setNodeData(getNextSegRuleTerm(nextNewNode.getNodeData()));
		return nextNewNode;
	}

	@SuppressWarnings("unchecked")
	private static SegDetailVO getNextSegRuleTerm(SegDetailVO nodeData)
			throws BusinessException {
		SegDetailVO ret = nodeData;
		Collection<SegRuleTermVO> terms = getBaseDAO().retrieveByClause(
				SegRuleTermVO.class,
				"pk_segrule='" + nodeData.getPk_segrule() + "' and dr=0",
				"segno");

		if (terms == null || terms.size() == 0) {
			throw new BusinessException("建新後mc失。何凑业揭言O定的分段t明");
		} else {
			int count = 0;
			boolean getThis = false;
			SegRuleTermVO nextTerm = null;
			for (SegRuleTermVO term : terms) {
				if (getThis) {
					nextTerm = term;
					break;
				}
				count++;
				if (term.getPk_segruleterm().equals(
						nodeData.getPk_segruleterm())) {
					if (count == terms.size()) {
						nextTerm = term;
					} else {
						getThis = true;
					}
				}
			}

			UFDouble start = nextTerm.getStartpoint();
			UFDouble end = nextTerm.getEndpoint();
			UFDouble rate = nextTerm.getOtrate();
			UFDouble weight = nextTerm.getAdditionalweight();
			UFDouble seghours = end.sub(start);
			ret.setPk_segruleterm(nextTerm.getPk_segruleterm());
			ret.setRulehours(seghours);
			ret.setOtrate(rate);
		}
		return ret;
	}

	/**
	 * 取所有上cCode完全一拥母骷父c加班r抵和
	 * 
	 * @param currentNode
	 * @return
	 */
	private static UFDouble getParentTotalHoursBySameCode(
			OTSChainNode currentNode) {
		UFDouble hours = currentNode.getNodeData().getHours();
		OTSChainNode curNode = currentNode;
		// 上c不榭眨且上c的ca=本次n加的ca
		while (curNode.getPriorNode() != null
				&& curNode.getPriorNode().getNodeData().getNodecode()
						.equals(currentNode.getNodeData().getNodecode())) {
			hours = hours.add(curNode.getPriorNode().getNodeData().getHours());
			curNode = curNode.getPriorNode();
		}
		return hours;
	}

	/**
	 * 查找父c
	 * 
	 * @param originalNode
	 *            原始c表
	 * @param checkNode
	 *            z查c
	 * @return
	 * @throws BusinessException
	 */
	private static OTSChainNode findParentNode(OTSChainNode originalNode,
			OTSChainNode checkNode) throws BusinessException {
		String checkedNodeCode = checkNode.getNodeData().getNodecode();
		String[] checkedCodeList = checkedNodeCode.split("_");
		OTSChainNode retNode = null;
		OTSChainNode curNode = getLastNode(originalNode);
		while (curNode.getPriorNode() != null) {
			// 向上ふ业谝NodeCode相同或者早於z查c
			String curNodeCode = curNode.getNodeData().getNodecode();
			String[] curCodeList = curNodeCode.split("_");
			if (curNodeCode.equals(checkedNodeCode)
					|| (curCodeList[0] == checkedCodeList[0] && (curCodeList[1] + curCodeList[3])
							.compareTo(checkedCodeList[1] + checkedCodeList[3]) <= 0)) {
				retNode = curNode;
				break;
			}
			curNode = curNode.getPriorNode();
		}
		return retNode;
	}

	/**
	 * 取所有c的加班分段明
	 * 
	 * @param node
	 *            c
	 * @return
	 * @throws BusinessException
	 */
	public static SegDetailVO[] getAllNodeData(OTSChainNode node)
			throws BusinessException {
		List<SegDetailVO> segDetailVOs = new ArrayList<SegDetailVO>();

		OTSChainNode curNode = getFirstNode(node);
		do {
			segDetailVOs.add(curNode.getNodeData());
			curNode = curNode.getNextNode();
		} while (curNode != null);

		return segDetailVOs.toArray(new SegDetailVO[0]);
	}
}
